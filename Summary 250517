# 3. method
# 어떤 특정 작업을 수행하기 위한 명령문의 집합
#  메소드의 사용 목적
# 1. 중복되는 코드를 메소드로 만들어 코드의 반복 사용을 피할 수 있다.
# 2. 코드의 가독성이 좋아진다.
# 3. 기능의 변경이 필요한 경우 메소드 부분만 수정하면 되기 때문에, 손쉬운 유지보수가 가능하다.



# method 사용 방법
# 접근제어자 반환타입 메소드이름 (매개변수 목록) {
# // 실행할 코드
# // 반환타입이 있을경우 반환타입에 맞게 return 작성
# // 반환타입이 void인 경우 생략
# return ...;
# }

# 1. 접근 제어자 : 메소드에 접근할 수 있는 범위
#   A. public : 어디서나 접근 가능
#   B. protected : 상속관계이거나 같은 패키지에서 접근 가능
#   C. default(생략가능) : 같은 패키지에서 접근 가능
#   D. private : 같은 클래스 내부에서만 접근 가능
# 2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입
#   A. void : 리턴값 없음
#   B. 기본 변수 자료형 : int, float, 등등
#   C. 오브젝트형 : String, 이외 사용자 정의타입
# 메소드와 API 2
#   3. 메소드 이름 : 메소드를 호출하기 위한 이름
#   4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들
#   5. 실행할 코드 : 메소드의 기능을 수행하는 코드

# 메소드 호출
# 미리 정의한 메소드는 참조연산자(.)를 통해 호출할 수 있다.
# public class Application {
# public static void main(String[] args) {
# Application app = new Application();
# //레퍼런스변수이름.메소드이름();
# app.methodA();
# //레퍼런스변수이름.메소드이름(매개변수1, 매개변수2, ...)
# app.methodB(10);
# }

#  메소드가 호출되면 stack 영역에 메소드를 위한 영역이 할당되고,
# 호출된 메소드들이 실행이 완료되면 stack 영역에 할당된 메모리 공간은 사라진다.
# 메소드가 완료된 이후에는 호출했던 위치로 다시 돌아가서 그 이후 작업을 실행하는데,
# methodA() → methodB() → methodC() 와 같이 호출되었기 때문에
# 메소드가 끝날 때는 methodC() → methodB() → methodA() 와 같이 돌아가게 된다.



### 전달인자(argument)와 매개변수(parameter)를 이용한 메소드 호출
# 변수의 종류
# 1. 지역변수 : 지역변수는 선언한 메소드 블럭 내부에서만 사용이 가능하다. 이것을 지역변수의 스코프라고 한다.
# 2. 매개변수
# 3. 전역변수(필드)
# 4. 클래스(static)변수
# 다른 메소드간 서로 공유해야 하는 값이 존재하는 경우
# 메소드 호출 시 사용하는 괄호를 이용해서 값을 전달할 수 있다.
# 이 때 전달하는 값을 전달인자(argument) 라고 부르고,
# 메소드 선언부 괄호 안에 전달 인자를 받기 위해 선언하는 변수를
# 매개변수(parameter)라고 부른다.
public static void main(String[] args) {
    methodA(10); // 여기서 10은 전달인자
}
public void methodA (int X) {
    System.out.println("매개변수 : " + X);
}
