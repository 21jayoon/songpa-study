# Transaction이란? What is transaction?
데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
출처: https://sunnyk.tistory.com/15 [오늘 공부:티스토리]

# 20250714 Developing Day 6
## 1. Attach UserRole from lecture source

## 2. Move AuthUserService's method into domain/user/service/UserService.java

    package com.header.header.domain.user.repository;
    
    import com.header.header.domain.user.entity.User;
    import org.apache.ibatis.annotations.Param;
    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Query;
    
    public interface MainUserRepository extends JpaRepository<User, Integer> {
    
        /* 예약자명과 예약자 번호를 통해 userCode 가져오기 - 주혜 */
        @Query( value = "SELECT u FROM User u WHERE u.userName LIKE CONCAT('%', :userName, '%') AND u.userPhone = :userPhone")
        User findByUserNameAndUserPhone(@Param("userName") String userName, @Param("userPhone") String userPhone);
    
        /* 고객 아이디를 통해 고객 정보 불러오기 - 정아 */
        User findByUserId(String userId);
    
        String userId(String userId);
    
        boolean existsByUserId(String userId);
    
        boolean existsByUserPhone(String userPhone);
    
        boolean existsByUserPhoneAndUserCodeNot(String userPhone, int userCode);
    }


    package com.header.header.domain.user.service;
    
    import com.header.header.auth.model.dto.AuthUserDTO;
    import com.header.header.auth.model.dto.LoginUserDTO;
    import com.header.header.auth.model.dto.SignupDTO;
    import com.header.header.auth.model.repository.AuthUserRepository;
    import com.header.header.domain.user.dto.UserDTO;
    import com.header.header.domain.user.entity.User;
    import com.header.header.domain.user.repository.MainUserRepository;
    import lombok.RequiredArgsConstructor;
    import org.modelmapper.ModelMapper;
    import org.springframework.security.core.userdetails.UsernameNotFoundException;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
        
    import java.util.NoSuchElementException;
    import java.util.Objects;
        
    import static com.header.header.auth.common.ApiResponse.*;
    import static com.header.header.auth.common.ApiResponse.SUCCESS_MODIFY_USER;
        
    @Service
    @RequiredArgsConstructor
    public class UserService {
    
        private final MainUserRepository userRepository;
        private final ModelMapper modelMapper;
        private final PasswordEncoder passwordEncoder;
    
        /**
         * dummy user을 추가한다.
         * dummy user = 이름과 전화번호만 있는 유령 유저 정보
         *
         * @param userName 유저 이름
         * @param userPhone 유저 핸드폰 번호
         * */
        @Transactional
        public User createUserByNameAndPhone(String userName, String userPhone){
            UserDTO userDTO = new UserDTO();
            userDTO.setUserName(userName);
            userDTO.setUserPhone(userPhone);
            return userRepository.save(modelMapper.map(userDTO, User.class));
        }
    
        /**
         * 이름과 핸드폰 번호로 userCode를 조회한다.
         *
         * @param userName 유저 이름
         * @param userPhone 유저 핸드폰 번호
         * */
        public Integer findUserByNameAndPhone(String userName, String userPhone){
            User find =  userRepository.findByUserNameAndUserPhone(userName, userPhone);
    
            return find != null ? find.getUserCode() : null;
        }
    
    
        /* save : registerNewUser
        -> SignupDTO 사용
        @param signupDTO 생성할 user 정보가 담긴 DTO
        @return 생성된 signupDTO(user관련 DTO)
        @throws ApiResponse 이미 존재하는 아이디나 전화번호일 때 */
        @Transactional
        public String registerNewUser(SignupDTO signupDTO) {
            //중복확인 1 : userId
            if (userRepository.existsByUserId(signupDTO.getUserId())) {
                return DUPLICATE_ID.getMessage();
            }
    
            //중복확인 2 : userPhone
            if (userRepository.existsByUserPhone(signupDTO.getUserPhone())) {
                return DUPLICATE_PHONE.getMessage();
            }
    
            // 비밀번호 암호화
            signupDTO.setUserPwd(passwordEncoder.encode(signupDTO.getUserPwd()));
    
            // DTO → Entity로 변환 후 저장
            User userEntity = modelMapper.map(signupDTO, User.class);
            User savedUser = userRepository.save(userEntity);
    
            // 저장된 userCode를 다시 DTO에 설정
            signupDTO.setUserCode(savedUser.getUserCode());
    
            return SUCCESS_REGISTER_USER.getMessage();
        }
    
        /*Read specific : Login
         * ID갖고 회원정보 조회하는 method 생성. 반환은 UserDTO로
         *
         * @param userCode
         * @return modelMapper
         * @throws IllegalAccessError */
        /*Spring-data-jpa: findById (Repository에서 제공해주는 메소드) 이용하는 방법*/
    
        public LoginUserDTO findByUserId(String userId) {
        User foundUser = userRepository.findByUserId(userId);
    
            LoginUserDTO login = modelMapper.map(foundUser, LoginUserDTO.class);
            if(!Objects.isNull(login)){
                return login;
            }else {
                throw new UsernameNotFoundException("해당하는 회원이 없습니다. 회원가입 후 로그인 해주십시오.");
            }
        }
    
        /*Update : Modify user information
         *
         * @param authUserDTO
         * @throws IllegalArgumentException */
        @jakarta.transaction.Transactional
        public String modifyUser(AuthUserDTO authUserDTO){
            // 1. 기존 유저 엔티티 조회 (예시로 userCode 또는 userId 기준으로 조회)
            User user = userRepository.findById(authUserDTO.getUserCode())
                    .orElseThrow(() -> new IllegalArgumentException("해당 유저가 존재하지 않습니다."));
    
            // 2. 이전에 사용한 값과 동일한지 확인
            if (authUserDTO.getUserPwd() != null && user.getUserPwd().equals(authUserDTO.getUserPwd())) {
                return authUserDTO.getUserPwd() + SAME_PASSWORD.getMessage();
            }
    
            if (authUserDTO.getUserPhone() != null && user.getUserPhone().equals(authUserDTO.getUserPhone())) {
                return authUserDTO.getUserPhone() + SAME_PHONE.getMessage();
            }
    
            if (authUserDTO.getUserName() != null && user.getUserName().equals(authUserDTO.getUserName())) {
                return authUserDTO.getUserName() + SAME_NAME.getMessage();
            }
    
            // 3. DB 전체와 비교, 전화번호 중복 확인 (자기 자신 제외)
            if (userRepository.existsByUserPhoneAndUserCodeNot(authUserDTO.getUserPhone(), authUserDTO.getUserCode())) {
                return DUPLICATE_PHONE.getMessage();
            }
    
            // 4. 도메인 메서드를 통한 정보 수정
            if (authUserDTO.getUserPwd() != null) user.modifyUserPassword(authUserDTO.getUserPwd());
            if (authUserDTO.getUserPhone() != null) user.modifyUserPhone(authUserDTO.getUserPhone());
            if (authUserDTO.getUserName() != null) user.modifyUserName(authUserDTO.getUserName());
    
            return SUCCESS_MODIFY_USER.getMessage();
        }
    
    
        /*DELETE
         -> deleteById() 말고
         실제론 Update가 사용되어야 함
         isLeave = true 형태로
         @param autuUserDTO
         */
        @jakarta.transaction.Transactional
        public void deleteUser(AuthUserDTO authUserDTO) {
            User user = userRepository.findById(authUserDTO.getUserCode())
                    .orElseThrow(() -> new NoSuchElementException("이미 탈퇴한 회원입니다"));
            user.modifyUserLeave(true);
        }
    }

## 3. Error!!! 
    Cannot invoke "com.header.header.auth.common.UserRole.getRole()" because the return value of "com.header.header.auth.model.dto.LoginUserDTO.getUserRole()" is null
    java.lang.NullPointerException: Cannot invoke "com.header.header.auth.common.UserRole.getRole()" because the return value of "com.header.header.auth.model.dto.LoginUserDTO.getUserRole()" is null

## 4. Add PwdEncoder in SecurityConfiguration
@Bean
public PasswordEncoder passwordEncoder(){
return new BCryptPasswordEncoder();  //pwd 암호화에 가장 많이 사용되는 알고리즘, BCryptPasswordEncoder
}

## 5. Delete AuthUserRepository

## 6. Remove AuthUserDTO

## 7. Change parameter in UserService

## 8. Delete UserRole

## 9. Change AuthUserServiceTests

    package com.header.header.domain.auth;
    
    import com.header.header.auth.common.ApiResponse;
    import com.header.header.domain.user.dto.UserDTO;
    import com.header.header.auth.model.dto.LoginUserDTO;
    import com.header.header.auth.model.dto.SignupDTO;
    import com.header.header.domain.user.entity.User;
    import com.header.header.domain.user.repository.MainUserRepository;
    import com.header.header.domain.user.service.UserService;
    import jakarta.transaction.Transactional;
    import org.junit.jupiter.api.DisplayName;
    import org.junit.jupiter.api.Order;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    
    import static org.junit.jupiter.api.Assertions.*;
    
    @SpringBootTest
    @Transactional // 테스트 후 데이터 롤백
    public class AuthUserServiceTests {
    @Autowired
    private UserService userService;
    
        @Autowired
        private MainUserRepository userRepository;
    
        @Test
        @Order(1)
        @DisplayName("회원가입(user 생성) + 중복 체크 테스트")
        void registerNewUserTest() {
            //given1. 기존 정보와 중복 없이 가입할 때
            SignupDTO newSignup = new SignupDTO();
            newSignup.setUserId("user41");
            newSignup.setUserPwd("user41pwd");
            newSignup.setUserName("Kim tolkong");
            newSignup.setUserPhone("010-1233-2567");
            newSignup.setBirthday("2000-12-31");
    
            //when
            Object result1 = userService.registerNewUser(newSignup);
    
            //then
            System.out.print("가입 성공 메세지: " + result1);
            System.out.println("가입 정보 확인: "+ newSignup);
    
            //given2. 중복된 userId 사용
            SignupDTO duplicateIdDTO = new SignupDTO();
            duplicateIdDTO.setUserId("kwoneunji"); // DB에 존재
            duplicateIdDTO.setUserPwd("test1234");
            duplicateIdDTO.setUserName("Test User");
            duplicateIdDTO.setUserPhone("010-9999-9999");
            duplicateIdDTO.setBirthday("2025-07-14");
    
            //when(중복 아이디 가입 시도)
            Object result2 = userService.registerNewUser(duplicateIdDTO);
    
            //then: 중복 아이디 메시지 확인
            assertEquals(ApiResponse.DUPLICATE_ID.getMessage(), result2);
            System.out.println("Check Id msg: "+result2);
    
            //given3. 중복된 전화번호로 가입 시도
            SignupDTO duplicatePhoneDTO = new SignupDTO();
            duplicatePhoneDTO.setUserId("unique_user_001");
            duplicatePhoneDTO.setUserPwd("pass001");
            duplicatePhoneDTO.setUserName("Unique User");
            duplicatePhoneDTO.setUserPhone("010-1004-1004"); // DB에 존재
            duplicatePhoneDTO.setBirthday("2025-07-10");
    
            //when
            Object result3 = userService.registerNewUser(duplicatePhoneDTO);
    
            //then: 중복 전화번호 메시지 확인
            assertEquals(ApiResponse.DUPLICATE_PHONE.getMessage(), result3);
            System.out.println("Check phone msg: "+ result3);
        }
    
        @Test
        @Order(2)
        @DisplayName("Read 로그인 테스트")
        void loginUserTest() {
            //given
            //1. 고객 정보 확인
            //when
            LoginUserDTO checkLoggedIn = userService.findByUserId("leegahyeon");
    
            //then
            assertNotNull(checkLoggedIn);
            assertNotNull(checkLoggedIn.getUserCode());
            assertNotNull(checkLoggedIn.getUserName());
            assertNotNull(checkLoggedIn.isAdmin());
    
            assertEquals("leegahyeon", checkLoggedIn.getUserId());
            assertEquals("leegahyeon", checkLoggedIn.getUserPwd());
            assertEquals("이가현", checkLoggedIn.getUserName());
            assertFalse(checkLoggedIn.isAdmin());
            System.out.println("고객 정보 확인: " + checkLoggedIn);
            //고객 정보 확인: LoginUserDTO(userCode=98, userId=leegahyeon, userPwd=leegahyeon, userName=이가현, isAdmin=false)
    
            //2. 관리자 정보 확인
            //when
            LoginUserDTO checkAdmin = userService.findByUserId("kwoneunji");
    
            //then
            assertNotNull(checkAdmin);
            assertNotNull(checkAdmin.getUserCode());
            assertNotNull(checkAdmin.getUserName());
            assertNotNull(checkLoggedIn.isAdmin());
    
            assertEquals("kwoneunji", checkAdmin.getUserId());
            assertEquals("kwoneunji", checkAdmin.getUserPwd());
            assertEquals("권은지", checkAdmin.getUserName());
            assertTrue(checkAdmin.isAdmin());
            System.out.println("관리자 정보 확인: " +checkAdmin);
            //관리자 정보 확인: LoginUserDTO(userCode=2, userId=kwoneunji, userPwd=kwoneunji, userName=권은지, isAdmin=true)
    
            //3. 존재하지 않는 userCode로 유저 정보 불러오기
            //when
            //LoginUserDTO checkNoUser = authUserService.findUserByUserId(31);
            //exception : 해당하는 회원이 없습니다. 회원가입 후 로그인 해주십시오.
        }
    
        @Test
        @Order(3)
        @DisplayName("Update 유저 정보 수정-1 비밀번호 수정 시 메세지 반환 확인")
        void modifyUserTest() {
            User dbuser = userRepository.findByUserId("leejeok");
    
            UserDTO updateDTO = new UserDTO();
            updateDTO.setUserCode(dbuser.getUserCode());
            updateDTO.setUserId(dbuser.getUserId());
            updateDTO.setUserPwd(dbuser.getUserPwd());
            System.out.println("original: " + updateDTO);
    
            // when1. 동일한 정보로 수정 시도
            String result = userService.modifyUser(updateDTO);
    
            // then(동일한 값에 대한 경고 메시지 확인)
            assertTrue(result.contains(ApiResponse.SAME_PASSWORD.getMessage()));
            System.out.println("동일한 비밀번호 메시지: " + result);
            //동일한 비밀번호 메시지: pwd29(은)는 이전 비밀번호와 동일합니다.
    
            // when2. 새로운 비밀번호(다른 값으)로 바꾸는 경우
            updateDTO.setUserPwd("newPwd29");
    
            //then
            String successResult = userService.modifyUser(updateDTO);
    
            assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
            System.out.println("비밀번호 수정 성공 메시지: " + successResult);
            //비밀번호 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
        }
    
        @Test
        @Order(4)
        @DisplayName("Update 유저 정보 수정-2 전화번호 수정 시 메세지 반환 및 중복 전화번호 확인")
        void modifyUserTest2() {
            // given: 기존 사용자 정보 조회
            User dbuser = userRepository.findByUserId("parkshinhye");
    
            UserDTO updateDTO2 = new UserDTO();
            updateDTO2.setUserCode(dbuser.getUserCode());
            updateDTO2.setUserId(dbuser.getUserId());
            updateDTO2.setUserPhone(dbuser.getUserPhone());
            System.out.println("original: " + updateDTO2);
            //original: UserDTO(userCode=35, userId=parkshinhye, userPwd=null, isAdmin=0, userName=null, userPhone=010-1035-1035, birthday=null, isLeave=0)
    
            // when1. 동일한 정보로 수정 시도
            String result2 = userService.modifyUser(updateDTO2);
    
            // then: 동일한 값에 대한 경고 메시지 확인
            System.out.println("Same modifying result: " + result2);
            //Same modifying result: 010-1035-1035(은)는 이전 전화번호와 동일합니다.
    
            assertTrue(result2.contains(ApiResponse.SAME_PHONE.getMessage()));
            //result2에 SAME_PHONE의 msg값이 들어가 있는지 확인
    
            // when2. 다른 값으로 바꾸는 경우
            updateDTO2.setUserPhone("010-1234-2222");
            String successResult = userService.modifyUser(updateDTO2);
    
            // then 변경 값 학인
            assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
            System.out.println("전화번호 수정 성공 메시지: " + successResult);
            //전화번호 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
            System.out.println("After modify phone: " + updateDTO2);
            //After modify phone: UserDTO(userCode=35, userId=parkshinhye, userPwd=null, isAdmin=0, userName=null, userPhone=010-1234-2222, birthday=null, isLeave=0))
        }
    
        @Test
        @Order(5)
        @DisplayName("Update 유저 정보 수정-3 이름 수정 시 메세지 반환 확인")
        void modifyUserTest3() {
            // given: 기존 사용자 정보 조회
            User dbuser = userRepository.findByUserId("suzy");
    
            UserDTO updateDTO3 = new UserDTO();
            updateDTO3.setUserCode(dbuser.getUserCode());
            updateDTO3.setUserName(dbuser.getUserName());
            System.out.println("original: " + updateDTO3);
            //original: UserDTO(userCode=29, userId=null, userPwd=null, isAdmin=false, userName=수지, userPhone=null, birthday=null, isLeave=false)
    
            // when1. 동일한 정보로 수정 시도
            String result = userService.modifyUser(updateDTO3);
    
            // then: 동일한 값에 대한 경고 메시지 확인
            assertTrue(result.contains(ApiResponse.SAME_NAME.getMessage()));
    
            System.out.println("ModifyUser result: " + result);
            //ModifyUser result: 수지(은)는 이전 이름과 동일합니다.
    
            // when2. 다른 값으로 바꾸는 경우
            updateDTO3.setUserName("배수지");
    
            // then 변경 값 학인
            String successResult = userService.modifyUser(updateDTO3);
            assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
            System.out.println("이름 수정 성공 메시지: " + successResult);
            System.out.println("After modify name: " + updateDTO3);
            //이름 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
            //After modify name: UserDTO(userCode=29, userId=null, userPwd=null, isAdmin=0, userName=배수지, userPhone=null, birthday=null, isLeave=0)
        }
    
        @Test
        @Order(6)
        @DisplayName("deleteUser() - 논리적 삭제(isLeave=true) 확인 테스트")
        void deleteUserTest() {
            // given
            String userId = "kimgurae";
            UserDTO dto = new UserDTO();
            dto.setUserId(userId);
            System.out.println("original:" + dto);
            //original:UserDTO(userCode=0, userId=kimgurae, userPwd=null, isAdmin=0, userName=null, userPhone=null, birthday=null, isLeave=0)
    
            // when
            userService.deleteUser(dto);
    
            // then: DB에서 다시 꺼내서 isLeave가 true로 바뀌었는지 확인
            User updatedUser = userRepository.findByUserId(userId);
            assertTrue(updatedUser.isLeave(), "이미 탈퇴한 회원입니다");
            System.out.println("isLeave 값: " + updatedUser.isLeave());
            //isLeave 값: true
        }
    }

## 10. Edit AuthUserServiceTests and BossReservationService

    @Test
    @DisplayName("BossReservation authorization Test")
    void adminReservationAuth () {
        // given
        User admin = userRepository.findByUserId("kwoneunji");
        User admin2 = userRepository.findByUserId("hwangkyungmi");
        User normal = userRepository.findByUserId("leegahyeon");
        User normal2 = userRepository.findByUserId("jungyumi");

        // when: 관리자는 예외 없이 접근 가능해야 함
        assertDoesNotThrow(() -> bossReservationService.accessReservation(admin));
        assertDoesNotThrow(() -> bossReservationService.accessReservation(admin2));

        // when: 일반 사용자는 예외 발생해야 함
        Exception exception = assertThrows(AccessDeniedException.class, () -> {
            bossReservationService.accessReservation(normal);
            bossReservationService.accessReservation(normal2);
        });

        // then
        assertEquals("관리자만 접근 가능합니다.", exception.getMessage());
        System.out.println("일반 유저 접근 시 에러 메시지: " + exception.getMessage());
    }

    public void accessReservation(User user) throws AccessDeniedException {
        if (!user.isAdmin()) {
            throw new AccessDeniedException("관리자만 접근 가능합니다.");
        }
    }

## 11. AuthUserServiceTests

    package com.header.header.domain.auth;

    import com.header.header.auth.common.ApiResponse;
    import com.header.header.domain.reservation.service.BossReservationService;
    import com.header.header.domain.sales.service.SalesService;
    import com.header.header.domain.user.dto.UserDTO;
    import com.header.header.auth.model.dto.LoginUserDTO;
    import com.header.header.auth.model.dto.SignupDTO;
    import com.header.header.domain.user.entity.User;
    import com.header.header.domain.user.repository.MainUserRepository;
    import com.header.header.domain.user.service.UserService;
    import jakarta.transaction.Transactional;
    import org.junit.jupiter.api.*;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    
    import java.nio.file.AccessDeniedException;
    
    import static org.junit.jupiter.api.Assertions.*;
    
    @SpringBootTest
    @Transactional // 테스트 후 데이터 롤백
    public class AuthUserServiceTests {
    @Autowired
    private UserService userService;
    
        @Autowired
        private MainUserRepository userRepository;
    
        @Autowired
        private BossReservationService bossReservationService;
    
        @Autowired
        private SalesService salesService;
    
        @Test
        @DisplayName("회원가입(user 생성) + 중복 체크 테스트")
        void registerNewUserTest() {
            //given1. 기존 정보와 중복 없이 가입할 때
            SignupDTO newSignup = new SignupDTO();
            newSignup.setUserId("user41");
            newSignup.setUserPwd("user41pwd");
            newSignup.setUserName("Kim tolkong");
            newSignup.setUserPhone("010-1233-2567");
            newSignup.setBirthday("2000-12-31");
    
            //when
            Object result1 = userService.registerNewUser(newSignup);
    
            //then
            System.out.print("가입 성공 메세지: " + result1);
            System.out.println("가입 정보 확인: "+ newSignup);
    
            //given2. 중복된 userId 사용
            SignupDTO duplicateIdDTO = new SignupDTO();
            duplicateIdDTO.setUserId("kwoneunji"); // DB에 존재
            duplicateIdDTO.setUserPwd("test1234");
            duplicateIdDTO.setUserName("Test User");
            duplicateIdDTO.setUserPhone("010-9999-9999");
            duplicateIdDTO.setBirthday("2025-07-14");
    
            //when(중복 아이디 가입 시도)
            Object result2 = userService.registerNewUser(duplicateIdDTO);
    
            //then: 중복 아이디 메시지 확인
            assertEquals(ApiResponse.DUPLICATE_ID.getMessage(), result2);
            System.out.println("Check Id msg: "+result2);
    
            //given3. 중복된 전화번호로 가입 시도
            SignupDTO duplicatePhoneDTO = new SignupDTO();
            duplicatePhoneDTO.setUserId("unique_user_001");
            duplicatePhoneDTO.setUserPwd("pass001");
            duplicatePhoneDTO.setUserName("Unique User");
            duplicatePhoneDTO.setUserPhone("010-1004-1004"); // DB에 존재
            duplicatePhoneDTO.setBirthday("2025-07-10");
    
            //when
            Object result3 = userService.registerNewUser(duplicatePhoneDTO);
    
            //then: 중복 전화번호 메시지 확인
            assertEquals(ApiResponse.DUPLICATE_PHONE.getMessage(), result3);
            System.out.println("Check phone msg: "+ result3);
        }
    
        @Test
        @DisplayName("Read 로그인 테스트")
        void loginUserTest() {
            //given
            //1. 고객 정보 확인
            //when
            LoginUserDTO checkLoggedIn = userService.findByUserId("leegahyeon");
    
            //then
            assertNotNull(checkLoggedIn);
            assertNotNull(checkLoggedIn.getUserCode());
            assertNotNull(checkLoggedIn.getUserName());
            assertNotNull(checkLoggedIn.isAdmin());
    
            assertEquals("leegahyeon", checkLoggedIn.getUserId());
            assertEquals("leegahyeon", checkLoggedIn.getUserPwd());
            assertEquals("이가현", checkLoggedIn.getUserName());
            assertFalse(checkLoggedIn.isAdmin());
            System.out.println("고객 정보 확인: " + checkLoggedIn);
            //고객 정보 확인: LoginUserDTO(userCode=98, userId=leegahyeon, userPwd=leegahyeon, userName=이가현, isAdmin=false)
    
            //2. 관리자 정보 확인
            //when
            LoginUserDTO checkAdmin = userService.findByUserId("kwoneunji");
    
            //then
            assertNotNull(checkAdmin);
            assertNotNull(checkAdmin.getUserCode());
            assertNotNull(checkAdmin.getUserName());
            assertNotNull(checkLoggedIn.isAdmin());
    
            assertEquals("kwoneunji", checkAdmin.getUserId());
            assertEquals("kwoneunji", checkAdmin.getUserPwd());
            assertEquals("권은지", checkAdmin.getUserName());
            assertTrue(checkAdmin.isAdmin());
            System.out.println("관리자 정보 확인: " +checkAdmin);
            //관리자 정보 확인: LoginUserDTO(userCode=2, userId=kwoneunji, userPwd=kwoneunji, userName=권은지, isAdmin=true)
    
            //3. 존재하지 않는 userCode로 유저 정보 불러오기
            //when
            //LoginUserDTO checkNoUser = authUserService.findUserByUserId(31);
            //exception : 해당하는 회원이 없습니다. 회원가입 후 로그인 해주십시오.
        }
    
        @Test
        @DisplayName("Update 유저 정보 수정-1 비밀번호 수정 시 메세지 반환 확인")
        void modifyUserTest() {
            User dbuser = userRepository.findByUserId("leejeok");
    
            UserDTO updateDTO = new UserDTO();
            updateDTO.setUserCode(dbuser.getUserCode());
            updateDTO.setUserId(dbuser.getUserId());
            updateDTO.setUserPwd(dbuser.getUserPwd());
            System.out.println("original: " + updateDTO);
    
            // when1. 동일한 정보로 수정 시도
            String result = userService.modifyUser(updateDTO);
    
            // then(동일한 값에 대한 경고 메시지 확인)
            assertTrue(result.contains(ApiResponse.SAME_PASSWORD.getMessage()));
            System.out.println("동일한 비밀번호 메시지: " + result);
            //동일한 비밀번호 메시지: pwd29(은)는 이전 비밀번호와 동일합니다.
    
            // when2. 새로운 비밀번호(다른 값으)로 바꾸는 경우
            updateDTO.setUserPwd("newPwd29");
    
            //then
            String successResult = userService.modifyUser(updateDTO);
    
            assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
            System.out.println("비밀번호 수정 성공 메시지: " + successResult);
            //비밀번호 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
        }
    
        @Test
        @DisplayName("Update 유저 정보 수정-2 전화번호 수정 시 메세지 반환 및 중복 전화번호 확인")
        void modifyUserTest2() {
            // given: 기존 사용자 정보 조회
            User dbuser = userRepository.findByUserId("parkshinhye");
    
            UserDTO updateDTO2 = new UserDTO();
            updateDTO2.setUserCode(dbuser.getUserCode());
            updateDTO2.setUserId(dbuser.getUserId());
            updateDTO2.setUserPhone(dbuser.getUserPhone());
            System.out.println("original: " + updateDTO2);
            //original: UserDTO(userCode=35, userId=parkshinhye, userPwd=null, isAdmin=0, userName=null, userPhone=010-1035-1035, birthday=null, isLeave=0)
    
            // when1. 동일한 정보로 수정 시도
            String result2 = userService.modifyUser(updateDTO2);
    
            // then: 동일한 값에 대한 경고 메시지 확인
            System.out.println("Same modifying result: " + result2);
            //Same modifying result: 010-1035-1035(은)는 이전 전화번호와 동일합니다.
    
            assertTrue(result2.contains(ApiResponse.SAME_PHONE.getMessage()));
            //result2에 SAME_PHONE의 msg값이 들어가 있는지 확인
    
            // when2. 다른 값으로 바꾸는 경우
            updateDTO2.setUserPhone("010-1234-2222");
            String successResult = userService.modifyUser(updateDTO2);
    
            // then 변경 값 학인
            assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
            System.out.println("전화번호 수정 성공 메시지: " + successResult);
            //전화번호 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
            System.out.println("After modify phone: " + updateDTO2);
            //After modify phone: UserDTO(userCode=35, userId=parkshinhye, userPwd=null, isAdmin=0, userName=null, userPhone=010-1234-2222, birthday=null, isLeave=0))
        }
    
        @Test
        @DisplayName("Update 유저 정보 수정-3 이름 수정 시 메세지 반환 확인")
        void modifyUserTest3() {
            // given: 기존 사용자 정보 조회
            User dbuser = userRepository.findByUserId("suzy29");
    
            UserDTO updateDTO3 = new UserDTO();
            updateDTO3.setUserCode(dbuser.getUserCode());
            updateDTO3.setUserName(dbuser.getUserName());
            System.out.println("original: " + updateDTO3);
            //original: UserDTO(userCode=29, userId=null, userPwd=null, isAdmin=0, userName=수지, userPhone=null, birthday=null, isLeave=0)
    
            // when1. 동일한 정보로 수정 시도
            String result = userService.modifyUser(updateDTO3);
    
            // then: 동일한 값에 대한 경고 메시지 확인
            assertTrue(result.contains(ApiResponse.SAME_NAME.getMessage()));
    
            System.out.println("ModifyUser result: " + result);
            //ModifyUser result: 수지(은)는 이전 이름과 동일합니다.
    
            // when2. 다른 값으로 바꾸는 경우
            updateDTO3.setUserName("배수지");
    
            // then 변경 값 학인
            String successResult = userService.modifyUser(updateDTO3);
            assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
            System.out.println("이름 수정 성공 메시지: " + successResult);
            System.out.println("After modify name: " + updateDTO3);
            //이름 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
            //After modify name: UserDTO(userCode=29, userId=null, userPwd=null, isAdmin=0, userName=배수지, userPhone=null, birthday=null, isLeave=0)
        }
    
        @Test
        @DisplayName("deleteUser() - 논리적 삭제(isLeave=true) 확인 테스트")
        void deleteUserTest() {
            // given
            String userId = "kimgurae";
            UserDTO dto = new UserDTO();
            dto.setUserId(userId);
            System.out.println("original:" + dto);
            //original:UserDTO(userCode=0, userId=kimgurae, userPwd=null, isAdmin=0, userName=null, userPhone=null, birthday=null, isLeave=0)
    
            // when
            userService.deleteUser(dto);
    
            // then: DB에서 다시 꺼내서 isLeave가 true로 바뀌었는지 확인
            User updatedUser = userRepository.findByUserId(userId);
            assertTrue(updatedUser.isLeave(), "이미 탈퇴한 회원입니다");
            System.out.println("isLeave 값: " + updatedUser.isLeave());
            //isLeave 값: true
        }
    
        @Test
        @DisplayName("Authorization test - BossReservation")
        void adminReservationAuthTest () {
            // given
            User admin = userRepository.findByUserId("kwoneunji");
            User admin2 = userRepository.findByUserId("hwangkyungmi");
            User normal = userRepository.findByUserId("leegahyeon");
            User normal2 = userRepository.findByUserId("jungyumi");
    
            // when1: 관리자는 예외 없이 접근 가능해야 함
            assertDoesNotThrow(() -> bossReservationService.accessReservation(admin));
            assertDoesNotThrow(() -> bossReservationService.accessReservation(admin2));
    
            // when2: 일반 사용자는 예외 발생해야 함
            Exception exception1 = assertThrows(AccessDeniedException.class, () -> {
                bossReservationService.accessReservation(normal);
            });
            Exception exception2 = assertThrows(AccessDeniedException.class, () -> {
                bossReservationService.accessReservation(normal2);
            });
    
            // then
            assertEquals("관리자 예약 페이지는 관리자만 접근 가능합니다.", exception1.getMessage());
            assertEquals("관리자 예약 페이지는 관리자만 접근 가능합니다.", exception2.getMessage());
            System.out.println("일반 유저1 접근 시 에러 메시지: " + exception1.getMessage());
            System.out.println("일반 유저2 접근 시 에러 메시지: " + exception2.getMessage());
            //일반 유저1 접근 시 에러 메시지: 관리자 예약 페이지는 관리자만 접근 가능합니다.
            //일반 유저2 접근 시 에러 메시지: 관리자 예약 페이지는 관리자만 접근 가능합니다.
        }
    
        @Test
        @DisplayName("Admin authorization2 - Sales entity")
        void adminSalesAuth() {
            // given
            User admin = userRepository.findByUserId("kwoneunji");
            User admin2 = userRepository.findByUserId("hwangkyungmi");
            User normal = userRepository.findByUserId("jungyumi");
    
            // when1: 관리자는 예외 없이 접근 가능해야 함
            assertDoesNotThrow(() -> salesService.accessSales(admin));
            assertDoesNotThrow(() -> salesService.accessSales(admin2));
    
            // when2: 일반 사용자는 예외 발생해야 함
            Exception exception = assertThrows(AccessDeniedException.class, () -> {
                salesService.accessSales(normal);
            });
    
            // then
            assertEquals("매출 관리는 관리자만 접근 가능합니다.", exception.getMessage());
            System.out.println("일반 유저 접근 시 에러 메시지: " + exception.getMessage());
            //일반 유저 접근 시 에러 메시지: 매출 관리는 관리자만 접근 가능합니다.
        }
    }

## 12. Make facade/UserFacadeService.java under domiain/user

    package com.header.header.domain.user.facade;

    import com.header.header.auth.model.dto.LoginUserDTO;
    import com.header.header.auth.model.dto.SignupDTO;
    import com.header.header.domain.user.dto.UserDTO;
    import com.header.header.domain.user.entity.User;
    import com.header.header.domain.user.service.UserService;
    import lombok.RequiredArgsConstructor;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    
    @Service
    @RequiredArgsConstructor
    public class UserFacadeService {
    
        private final UserService userService;
    
        /* 1. 더미 유저 등록 (전화번호/이름 기반)
        * 업장에서 전화번호 + 이름만으로 임시 가입한 dummy user 생성 */
        @Transactional
        public User registerDummyUser(String userName, String userPhone) {
            return userService.createUserByNameAndPhone(userName, userPhone);
        }
    
        /* 2. 이름/전화번호로 유저 코드 조회 */
        public Integer getUserCodeByNameAndPhone(String name, String phone) {
            return userService.findUserByNameAndPhone(name, phone);
        }
    
        /* 3. 회원가입 처리 (중복검사 포함) */
        @Transactional
        public String registerUser(SignupDTO signupDTO) {
            return userService.registerNewUser(signupDTO);
        }
    
        /* 4. 로그인 시 유저 정보 조회 */
        public LoginUserDTO login(String userId) {
            return userService.findByUserId(userId);
        }
    
        /* 5. 회원 정보 수정 */
        @Transactional
        public String updateUser(UserDTO dto) {
            return userService.modifyUser(dto);
        }
    
        /* 6. 회원 탈퇴 처리 (isLeave = true) */
        @Transactional
        public void deleteUser(UserDTO dto) {
            userService.deleteUser(dto);
        }
    }

## 13. UserFacadeService 변경 값에 따라 AuthUserServiceTests 리팩토링

    @SpringBootTest
@Transactional // 테스트 후 데이터 롤백
public class AuthUserServiceTests {
@Autowired
private UserService userService;

    @Autowired
    private UserFacadeService facadeService;

    @Autowired
    private MainUserRepository userRepository;

    @Autowired
    private BossReservationService bossReservationService;

    @Autowired
    private SalesService salesService;
    private UserDTO updateDTO;

    @Test
    @DisplayName("회원가입(user 생성) + 중복 체크 테스트")
    void registerUserTest() {
        //given1. 기존 정보와 중복 없이 가입할 때
        SignupDTO newSignup = new SignupDTO();
        newSignup.setUserId("user41");
        newSignup.setUserPwd("user41pwd");
        newSignup.setUserName("Kim tolkong");
        newSignup.setUserPhone("010-1233-2567");
        newSignup.setBirthday("2000-12-31");

        //when
        Object result1 = facadeService.registerUser(newSignup);

        //then
        System.out.println("가입 성공 메세지: " + result1);
        System.out.println("가입 정보 확인: "+ newSignup);
        //가입 성공 메세지: 회원가입이 완료되었습니다.
        //가입 정보 확인: SignupDTO(userCode=101, userName=Kim tolkong, userPhone=010-1233-2567, userId=user41, userPwd=$2a$10$L3Md/JUWLKOGKBEwOSunD.VaonwaE.SAxZW8KZX5KcICbPBb7LlDG, birthday=2000-12-31)

        //given2. 중복된 userId 사용
        SignupDTO duplicateIdDTO = new SignupDTO();
        duplicateIdDTO.setUserId("kwoneunji"); // DB에 존재
        duplicateIdDTO.setUserPwd("test1234");
        duplicateIdDTO.setUserName("Test User");
        duplicateIdDTO.setUserPhone("010-9999-9999");
        duplicateIdDTO.setBirthday("2025-07-14");

        //when(중복 아이디 가입 시도)
        Object result2 = facadeService.registerUser(duplicateIdDTO);

        //then: 중복 아이디 메시지 확인
        assertEquals(ApiResponse.DUPLICATE_ID.getMessage(), result2);
        System.out.println("Check Id msg: "+result2);
        //Check Id msg: 이미 존재하는 아이디입니다.

        //given3. 중복된 전화번호로 가입 시도
        SignupDTO duplicatePhoneDTO = new SignupDTO();
        duplicatePhoneDTO.setUserId("newuser01");
        duplicatePhoneDTO.setUserPwd("pass001");
        duplicatePhoneDTO.setUserName("Jane Doe");
        duplicatePhoneDTO.setUserPhone("010-1004-1004"); // DB에 존재
        duplicatePhoneDTO.setBirthday("2025-07-10");

        //when
        Object result3 = facadeService.registerUser(duplicatePhoneDTO);

        //then: 중복 전화번호 메시지 확인
        assertEquals(ApiResponse.DUPLICATE_PHONE.getMessage(), result3);
        System.out.println("Check phone msg: "+ result3);
        //Check phone msg: 이미 존재하는 전화번호입니다.
    }

    @Test
    @DisplayName("Read 로그인 테스트")
    void facadeLoginTest() {
        //given
        //1. 고객 정보 확인
        //when
        LoginUserDTO checkLoggedIn = facadeService.login("leegahyeon");

        //then
        assertNotNull(checkLoggedIn);
        assertNotNull(checkLoggedIn.getUserCode());
        assertNotNull(checkLoggedIn.getUserName());
        assertNotNull(checkLoggedIn.isAdmin());

        assertEquals("leegahyeon", checkLoggedIn.getUserId());
        assertEquals("leegahyeon", checkLoggedIn.getUserPwd());
        assertEquals("이가현", checkLoggedIn.getUserName());
        assertFalse(checkLoggedIn.isAdmin());
        System.out.println("고객 정보 확인: " + checkLoggedIn);
        //고객 정보 확인: LoginUserDTO(userCode=98, userId=leegahyeon, userPwd=leegahyeon, userName=이가현, isAdmin=false)

        //2. 관리자 정보 확인
        //when
        LoginUserDTO checkAdmin = facadeService.login("kwoneunji");

        //then
        assertNotNull(checkAdmin);
        assertNotNull(checkAdmin.getUserCode());
        assertNotNull(checkAdmin.getUserName());
        assertNotNull(checkLoggedIn.isAdmin());

        assertEquals("kwoneunji", checkAdmin.getUserId());
        assertEquals("kwoneunji", checkAdmin.getUserPwd());
        assertEquals("권은지", checkAdmin.getUserName());
        assertTrue(checkAdmin.isAdmin());
        System.out.println("관리자 정보 확인: " +checkAdmin);
        //관리자 정보 확인: LoginUserDTO(userCode=2, userId=kwoneunji, userPwd=kwoneunji, userName=권은지, isAdmin=true)

        //3. 존재하지 않는 userId로 유저 정보 불러오기
        // given
        // when
        UsernameNotFoundException exception = assertThrows(
                UsernameNotFoundException.class,
                () -> facadeService.login("user01")  // 존재하지 않는 아이디
        );

        //then
        assertEquals("해당하는 회원이 없습니다. 회원 가입 후 로그인 해주십시오.", exception.getMessage());
    }

    @Test
    @DisplayName("Update 유저 정보 수정-1 비밀번호 수정 시 메세지 반환 확인")
    void modifyUserTest() {
        // given
        LoginUserDTO dbUser = facadeService.login("choiminsu");

        UserDTO updateDTO = new UserDTO();
        updateDTO.setUserCode(dbUser.getUserCode());
        updateDTO.setUserPwd(dbUser.getUserPwd()); // 동일한 비밀번호 설정
        System.out.println("original: " + updateDTO);
        //original: UserDTO(userCode=6, userId=null, userPwd=choiminsu, isAdmin=0, userName=null, userPhone=null, birthday=null, isLeave=0)

        // when1. 동일한 정보로 수정 시도
        String result = facadeService.updateUser(updateDTO);

        // then(동일한 값에 대한 경고 메시지 확인)
        assertTrue(result.contains(ApiResponse.SAME_PASSWORD.getMessage()));
        System.out.println("동일한 비밀번호 메시지: " + result);
        //동일한 비밀번호 메시지: choiminsu(은)는 이전 비밀번호와 동일합니다.

        // when2. 새로운 비밀번호(다른 값으)로 바꾸는 경우
        updateDTO.setUserPwd("newPwd29");

        //then
        String successResult = facadeService.updateUser(updateDTO);
        System.out.println("NewPwd: " + updateDTO);
        //NewPwd: UserDTO(userCode=6, userId=null, userPwd=newPwd, isAdmin=0, userName=null, userPhone=null, birthday=null, isLeave=0)

        assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
        System.out.println("비밀번호 수정 성공 메시지: " + successResult);
        //비밀번호 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
    }


## 14. LoginUserDTO에 userPhone 추가
Tests에서 전화번호 수정하는 경우 LoginDTO를 통해 전화번호를 받아와야하는데 없어서 Test 자체가 불가능한 상황을 해결했음

    package com.header.header.auth.model.dto;
    
    import lombok.Getter;
    import lombok.Setter;
    import lombok.ToString;
    
    
    @Getter
    @Setter
    @ToString
    public class LoginUserDTO {
        private int userCode;
        private String userId;
        private String userPwd;
        private String userName;
        private String userPhone;
        private boolean isAdmin;
    }

## 15. Go through another Tests

    @Test
    @DisplayName("Update 유저 정보 수정-2 전화번호 수정 시 메세지 반환 및 중복 전화번호 확인")
    void modifyUserTest2() {
        // given: 기존 사용자 정보 조회
        LoginUserDTO dbuser = facadeService.login("parkshinhye");

        UserDTO updateDTO2 = new UserDTO();
        updateDTO2.setUserCode(dbuser.getUserCode());
        updateDTO2.setUserId(dbuser.getUserId());
        updateDTO2.setUserPhone(dbuser.getUserPhone());
        System.out.println("original: " + updateDTO2);
        //original: UserDTO(userCode=35, userId=parkshinhye, userPwd=null, isAdmin=0, userName=null, userPhone=010-1035-1035, birthday=null, isLeave=0)

        // when1. 동일한 정보로 수정 시도
        String result2 = facadeService.updateUser(updateDTO2);

        // then: 동일한 값에 대한 경고 메시지 확인
        System.out.println("Same modifying result: " + result2);
        //Same modifying result: 010-1035-1035(은)는 이전 전화번호와 동일합니다.

        assertTrue(result2.contains(ApiResponse.SAME_PHONE.getMessage()));
        //result2에 SAME_PHONE의 msg값이 들어가 있는지 확인

        // when2. 다른 값으로 바꾸는 경우
        updateDTO2.setUserPhone("010-1234-2222");
        String successResult = facadeService.updateUser(updateDTO2);

        // then 변경 값 학인
        assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
        System.out.println("전화번호 수정 성공 메시지: " + successResult);
        //전화번호 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
        System.out.println("After modify phone: " + updateDTO2);
        //After modify phone: UserDTO(userCode=35, userId=parkshinhye, userPwd=null, isAdmin=0, userName=null, userPhone=010-1234-2222, birthday=null, isLeave=0))
    }

    @Test
    @DisplayName("Update 유저 정보 수정-3 이름 수정 시 메세지 반환 확인")
    void modifyUserTest3() {
        // given: 기존 사용자 정보 조회
        LoginUserDTO dbuser = facadeService.login("suzy29");

        UserDTO updateDTO3 = new UserDTO();
        updateDTO3.setUserCode(dbuser.getUserCode());
        updateDTO3.setUserName(dbuser.getUserName());
        System.out.println("original: " + updateDTO3);
        //original: UserDTO(userCode=29, userId=null, userPwd=null, isAdmin=0, userName=수지, userPhone=null, birthday=null, isLeave=0)

        // when1. 동일한 정보로 수정 시도
        String result = facadeService.updateUser(updateDTO3);

        // then: 동일한 값에 대한 경고 메시지 확인
        assertTrue(result.contains(ApiResponse.SAME_NAME.getMessage()));

        System.out.println("ModifyUser result: " + result);
        //ModifyUser result: 수지(은)는 이전 이름과 동일합니다.

        // when2. 다른 값으로 바꾸는 경우
        updateDTO3.setUserName("배수지");

        // then 변경 값 학인
        String successResult = facadeService.updateUser(updateDTO3);
        assertEquals(ApiResponse.SUCCESS_MODIFY_USER.getMessage(), successResult);
        System.out.println("이름 수정 성공 메시지: " + successResult);
        System.out.println("After modify name: " + updateDTO3);
        //이름 수정 성공 메시지: 회원 정보가 성공적으로 수정되었습니다.
        //After modify name: UserDTO(userCode=29, userId=null, userPwd=null, isAdmin=0, userName=배수지, userPhone=null, birthday=null, isLeave=0)
    }

    @Test
    @DisplayName("withdrawUser() - 회원탈퇴 : 논리적 삭제(isLeave=true) 확인 테스트")
    void withdrawUserTest() {
        // given
        String userId = "kimgurae";
        UserDTO dto = new UserDTO();
        dto.setUserId(userId);
        System.out.println("original:" + dto);
        //original:UserDTO(userCode=0, userId=kimgurae, userPwd=null, isAdmin=0, userName=null, userPhone=null, birthday=null, isLeave=0)

        // when
        facadeService.withdrawUser(dto);

        // then: DB에서 다시 꺼내서 isLeave가 true로 바뀌었는지 확인
        User updatedUser = userRepository.findByUserId(userId);
        assertTrue(updatedUser.isLeave(), "이미 탈퇴한 회원입니다");
        System.out.println("isLeave 값: " + updatedUser.isLeave());
        //isLeave 값: true
    }

    @Test
    @DisplayName("Authorization test - BossReservation")
    void adminReservationAuthTest () {
        // given
        User admin = userRepository.findByUserId("kwoneunji");
        User admin2 = userRepository.findByUserId("hwangkyungmi");
        User normal = userRepository.findByUserId("leegahyeon");
        User normal2 = userRepository.findByUserId("jungyumi");

        // when1: 관리자는 예외 없이 접근 가능해야 함
        assertDoesNotThrow(() -> facadeService.adminRetrieveReservation(admin));
        assertDoesNotThrow(() -> facadeService.adminRetrieveReservation(admin2));

        // when2: 일반 사용자는 예외 발생해야 함
        Exception exception1 = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminRetrieveReservation(normal);
        });
        Exception exception2 = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminRetrieveReservation(normal2);
        });

        // then
        assertEquals("관리자 예약 페이지는 관리자만 접근 가능합니다.", exception1.getMessage());
        assertEquals("관리자 예약 페이지는 관리자만 접근 가능합니다.", exception2.getMessage());
        System.out.println("일반 유저1 접근 시 에러 메시지: " + exception1.getMessage());
        System.out.println("일반 유저2 접근 시 에러 메시지: " + exception2.getMessage());
        //일반 유저1 접근 시 에러 메시지: 관리자 예약 페이지는 관리자만 접근 가능합니다.
        //일반 유저2 접근 시 에러 메시지: 관리자 예약 페이지는 관리자만 접근 가능합니다.
    }

    @Test
    @DisplayName("Admin authorization2 - Sales entity")
    void adminSalesAuth() {
        // given
        User admin = userRepository.findByUserId("kwoneunji");
        User admin2 = userRepository.findByUserId("hwangkyungmi");
        User normal = userRepository.findByUserId("jungyumi");

        // when1: 관리자는 예외 없이 접근 가능해야 함
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin));
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin2));

        // when2: 일반 사용자는 예외 발생해야 함
        Exception exception = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminSalesLookup(normal);
        });

        // then
        assertEquals("매출 관리는 관리자만 접근 가능합니다.", exception.getMessage());
        System.out.println("일반 유저 접근 시 에러 메시지: " + exception.getMessage());
        //일반 유저 접근 시 에러 메시지: 매출 관리는 관리자만 접근 가능합니다.
    }

## 16. Edit Authorization Method's parameter in UserFacadeService
Reference : https://chatgpt.com/share/6874c01c-06b4-8003-879a-f153634a6936

(Now)

    /* 7. BossReservation Authorization 처리 */
    @Transactional
    public void adminRetrieveReservation(LoginUserDTO loginUserDTO) throws AccessDeniedException {
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        bossReservationService.accessReservation(user);
    }

    /* 8. SalesService Authorization 처리 */
    @Transactional
    public void adminSalesLookup(LoginUserDTO loginUserDTO) throws AccessDeniedException {
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        salesService.accessSales(user);
    }

    /* 9. Message Authorization 처리 */
    @Transactional
    public void adminMsgAuthorize(LoginUserDTO loginUserDTO) throws AccessDeniedException {
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        messageSendBatchService.accessMSB(user);
    }

(Before)

    /* 7. BossReservation Authorization 처리 */
    @Transactional
    public void adminRetrieveReservation(User user) throws AccessDeniedException {
        bossReservationService.accessReservation(user);
    }

    /* 8. SalesService Authorization 처리 */
    @Transactional
    public void adminSalesLookup(User user) throws AccessDeniedException {
        salesService.accessSales(user);
    }

    /* 9. Message Authorization 처리 */
    @Transactional
    public void adminMsgAuthorize(User user) throws AccessDeniedException {
        messageSendBatchService.accessMSB(user);
    }

## 17. Revise MessageTemplateService and MessageSendBatchService

    // 관리자 authorization
    public void accessMsgTemplate(User user) throws AccessDeniedException {
        if (!user.isAdmin()) {
            throw new AccessDeniedException("이 페이지는 관리자만 접근 가능합니다.");
        }
    }

    /* Authorization */
    /**
     * isAdmin=true인 user만 접근 가능
     * (이 메소드는 UserFacadeService를 통해
     * AuthUserServiceTests - adminMSBauthorize에서 사용됩니다)
     *
     * @param user
     * @throw AccessDeniedException */
    public void accessMSB(User user) throws AccessDeniedException {
        if (!user.isAdmin()) {
            throw new AccessDeniedException("이 페이지는 관리자만 접근 가능합니다.");
        }
    }

## 18. UserFacadeService

    /* 7. BossReservation Authorization 처리 */
    @Transactional
    public void adminRetrieveReservation(LoginUserDTO loginUserDTO) throws AccessDeniedException {
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        bossReservationService.accessReservation(user);
    }

    /* 8. SalesService Authorization 처리 */
    @Transactional
    public void adminSalesLookup(LoginUserDTO loginUserDTO) throws AccessDeniedException {
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        salesService.accessSales(user);
    }

    /* 9. Message Authorization 처리 */
    @Transactional
    public void adminMsgAuthorize(LoginUserDTO loginUserDTO) throws AccessDeniedException {
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        messageSendBatchService.accessMSB(user);
    }

    /* 10. MsgTemplate 처리 */
    @Transactional
    public void adminMsgTemplateAuthorize(LoginUserDTO loginUserDTO) throws AccessDeniedException{
        User user = userRepository.findByUserId(loginUserDTO.getUserId());
        messageTemplateService.accessMsgTemplate(user);
    }

## 19. Rephrase AuthUserServiceTests

    @Test
    @DisplayName("Authorization test - BossReservation")
    void adminReservationAuthTest () {
        // given
        LoginUserDTO admin1 = facadeService.login("kwoneunji");
        LoginUserDTO admin2 = facadeService.login("hwangkyungmi");

        LoginUserDTO normal = facadeService.login("iu1234");
        LoginUserDTO normal2 = facadeService.login("limyoona");

        // when1: 관리자는 예외 없이 접근 가능해야 함
        assertDoesNotThrow(() -> facadeService.adminRetrieveReservation(admin1));
        assertDoesNotThrow(() -> facadeService.adminRetrieveReservation(admin2));

        // when2: 일반 사용자는 예외 발생해야 함
        Exception exception1 = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminRetrieveReservation(normal);
        });
        Exception exception2 = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminRetrieveReservation(normal2);
        });

        // then
        assertEquals("관리자 예약 페이지는 관리자만 접근 가능합니다.", exception1.getMessage());
        assertEquals("관리자 예약 페이지는 관리자만 접근 가능합니다.", exception2.getMessage());
        System.out.println("일반 유저1 접근 시 에러 메시지: " + exception1.getMessage());
        System.out.println("일반 유저2 접근 시 에러 메시지: " + exception2.getMessage());
        //일반 유저1 접근 시 에러 메시지: 관리자 예약 페이지는 관리자만 접근 가능합니다.
        //일반 유저2 접근 시 에러 메시지: 관리자 예약 페이지는 관리자만 접근 가능합니다.
    }

    @Test
    @DisplayName("Admin authorization2 - Sales")
    void adminSalesAuthorize() {
        // given
        LoginUserDTO admin1 = facadeService.login("kwoneunji");
        LoginUserDTO admin2 = facadeService.login("hwangkyungmi");
        LoginUserDTO normal = facadeService.login("jungyumi");

        // when1: 관리자 접근 가능 (예외 발생 x)
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin1));
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin2));

        // when2: 일반 사용자는 예외 발생해야 함
        Exception exception = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminSalesLookup(normal);
        });

        // then
        assertEquals("매출 관리는 관리자만 접근 가능합니다.", exception.getMessage());
        System.out.println("일반 유저 접근 시 에러 메시지: " + exception.getMessage());
        //일반 유저 접근 시 에러 메시지: 매출 관리는 관리자만 접근 가능합니다.
    }

    @Test
    @DisplayName("Admin Authorization3 - message1 : MessageSendBatch")
    void adminMSBauthorize () {
        //given
        LoginUserDTO admin1 = facadeService.login("kwoneunji");
        LoginUserDTO admin2 = facadeService.login("hwangkyungmi");
        LoginUserDTO normal = facadeService.login("najaeemin");

        // when1: 관리자 접근 가능(예외 발생x)
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin1));
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin2));

        // when2: 일반 사용자는 예외 발생해야 함
        Exception exception = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminMsgAuthorize(normal);
        });

        //then
        assertEquals("이 페이지는 관리자만 접근 가능합니다.", exception.getMessage());
        System.out.println("Exception msg: " + exception.getMessage());
        //Exception msg: 이 페이지는 관리자만 접근 가능합니다.
    }

    @Test
    @DisplayName("Admin Authorization3 - message2 : MessageTemplate")
    void adminMsgTemplateAuthorize () {
        //given
        LoginUserDTO admin1 = facadeService.login("kwoneunji");
        LoginUserDTO admin2 = facadeService.login("hwangkyungmi");
        LoginUserDTO normal = facadeService.login("kwaneunbi");

        // when1: 관리자 접근 가능(예외 발생x)
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin1));
        assertDoesNotThrow(() -> facadeService.adminSalesLookup(admin2));

        // when2: 일반 사용자는 예외 발생해야 함
        Exception exception = assertThrows(AccessDeniedException.class, () -> {
            facadeService.adminMsgTemplateAuthorize(normal);
        });

        //then
        assertEquals("이 페이지는 관리자만 접근 가능합니다.", exception.getMessage());
        System.out.println("MsgTemplate Exception: " + exception.getMessage());
        //MsgTemplate Exception: 이 페이지는 관리자만 접근 가능합니다.
    }

## 20. 참고용 링크들
https://velog.io/@happy_code/%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85-%EA%B8%B0%EB%8A%A5-%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-%ED%83%88%ED%87%B4%ED%95%9C-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC-%EB%B0%8F-UserDetails-%EA%B4%80%EB%A0%A8-%EC%9D%B4%EC%8A%88
https://inpa.tistory.com/entry/CS-%F0%9F%91%A8%E2%80%8D%F0%9F%92%BB-Authentication-vs-Authorization-%EC%B0%A8%EC%9D%B4-%EC%97%84%EC%B2%AD-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85
https://medium.com/@hongseongho/ci-cd-%ED%94%8C%EB%9E%AB%ED%8F%BC%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-8ca07a16933c
https://www.redhat.com/en/topics/devops/what-is-ci-cd

https://velog.io/@lsj8367/Facade-Pattern-%EC%A0%81%EC%9A%A9%EA%B8%B0
