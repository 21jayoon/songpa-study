# Starts to note from 20250727
-- Backend
- 객체 지향 언어 장점 pros of OOP language(Object-Oriented Language)
객체 지향 언어(예. Java)로 프로그래밍하면 공통으로 사용하는 부분*을 수정하지 않고도
프로그램에 새 기능을 쉽게 추가할 수 있다.
-> 유지보수성 & 확장성 good
(OOP : Object Oriented Programming)
* 여러 객체들이 공유하는 속성, 메서드(행동), 인터페이스 정의 등

# When developers program with an OOP language(e.g. Java),
# they can easily add new function
# without modifying shared components such as methods or interface definitions.


--Frontend
- 자바스크립트 함수에 대해 아는대로 설명해주세요.
자바스크립트 함수의 특징에는 일급 객체, 호이스팅, 클로저가 있습니다.

일급객체*인 JS 함수는 값처럼 취급될 수 있어
변수에 할당하거나 (1)
다른 함수의 인자로 전달하거나 (2)
함수의 반환값으로 사용할 수 있습니다. (3)

두번째 특징 호이스팅은
함수 선언식을 통해 선언한 함수는 코드가 실행되기 전,
즉 함수 선언 이전에도 호출할 수 있다는 것입니다. (4)
이를 '호이스팅되다'라고 합니다.
(다만, 함수 표현식은 변수에 할당된 후에 사용 가능합니다.)

마지막 특징 클로저는
자신이 선언된 스코프(=선언 환경)를 기억하고
해당 환경에 접근할 수 있는 기능입니다. (5)
자바스크립트 함수로 클로저를 구현할 수 있으며,
이를 통해 함수는 자신이 선언된 당시 스코프 내의 변수를 참조할 수 있습니다.

이 세 가지 특징을 통해 자바 스크립트 코드를 매우 유연하게 작성할 수 있고, (코드 내에서) 다양한 패턴을 구현할 수 있습니다.
(일급 객체, 익명함수, 호이스팅, 클로저, 고차 함수, 화살표 함수)

e.g.
``` javascript
const sayHello = function() { return 'Hello'; };  // (1) 'sayHello' 변수에 함수가 할당됨
console.log(sayHello()); // 'Hello'

const executeFunction = function(fn) { // (2) 'fn'은 다른 함수(sayHello)를 인자로 받는 부분
  return fn();  // (3) 'executeFunction'이 인자로 받은 함수('fn')의 실행 결과를 반환값으로 사용
};
console.log(executeFunction(sayHello)); // executeFunction(sayHello); -->'sayHello' 함수를 'executeFunction'의 인자로 전달 (2)


console.log(declaredFunction()); // 'Declared Function', (4) declaredFunction 함수가 호이스팅 됨.
function declaredFunction() {
  return 'Declared Function';
}

// 함수 표현식은 할당 후에만 사용할 수 있음
const expressedFunction = function() {
  return 'Expressed Function';
};
console.log(expressedFunction()); // 'Expressed Function'


function outer() {
  const outerVar = 'I am outer!';

  return function inner() { // (5) The 'inner' function, returned by 'outer', forms a closure. It "remembers" its environment (where 'outerVar' exists)
    return outerVar; // 외부 변수에 접근 가능
  };
}

const innerFunction = outer();
console.log(innerFunction()); // 'I am outer!' , (5) Therefore, 'outerVar' can be accessed even though function'outer' has already finished executing.
```

* '일급' 이란 뜻은 일급 시민처럼 무슨 혜택을 받는단 뜻이 아니라,
'사용할 때 다른 요소들과 아무런 차별이 없다는 것'을 뜻한다.
그리고 보통 일급 객체를 아래 3가지 조건을 충족한 객체를 일컫는다.

1. 모든 일급 객체는 변수나 데이터에 담을 수 있어야 한다.
2. 모든 일급 객체는 함수의 파라미터로 전달 할 수 있어야 한다.
3. 모든 일급 객체는 함수의 리턴값으로 사용 할수 있어야 한다.

(일급 객체는 어떠한 특정 언어에 국한되는 문법 단어가 아니다.)

참고Reference : https://www.maeil-mail.kr/question/33
https://inpa.tistory.com/entry/CS-👨‍💻-일급-객체first-class-object [Inpa Dev 👨‍💻:티스토리]
https://g.co/gemini/share/9275e97e83ad



- useEffect가 호출되는 시점에 대해 설명해 주세요.
React의 'useEffect'는 컴포넌트의 특정 시점에 자동으로 호출되는 Hook으로, 컴포넌트가
1. 마운트
2. 업데이트
3. 언마운트
되는 시점에 호출됩니다.

먼저 useEffect는 처음 렌더링되고 난 후, 즉 '컴포넌트가 마운트될 때' 호출됩니다.
이때 데이터 초기화나 외부 API 호출 등의 작업을 수행해
useEffect는 컴포넌트가 처음 마운트될 때 필요한 초기 작업을 수행할 수 있도록 해준다는 것을
알 수 있습니다.

또한 useEffect는 의존성 배열에 지정된 값이 변경될 때마다 다시 호출됩니다. 
이때, useEffect의 return 값으로 지정된 cleanup 함수가
이전 props 및 state와 함께 먼저 호출된 후 
본문의 실행로직이 업데이트된 props 맟 state와 함께 실행됩니다.

두 번째 인자로 주어지는 "의존성 배열은 useEffect가
어떤 상태 혹은 어떤 props의 변화에 반응할지를 결정합니다."
예를 들어 useEffect(() => {...}, [count])처럼 count 상태가 의존성 배열에 있을 경우
count 값이 변경될 때마다 useEffect가 호출됩니다.
이 의존성 배열 설정을 통해 
특정 상태나 props가 변경될 때마다 필요한 동작을 수행하도록 할 수 있으며,
컴포넌트의 변화에 따라 '동적으로' 실행되는 로직을 설정할 수 있습니다.
단, 의존성 배열을 넘기지 않을 경우(빈 의존성 배열 [] 설정 시),
useEffect가 매 렌더링마다 호출됩니다.

마지막으로 컴포넌트가 언마운트unmount 될 때,
useEffect의 return 값으로 지정된 클린업 함수가 호출됩니다.
이 정리함수를 이용해 이벤트 리스너 제거 등의 작업을 수행할 수 있습니다.
클린업 함수를 통해 useEffect를 통해 발생한 부수효과를 정리하는 것입니다.

최종적으로 한 줄로 정리를 해보자면
useEffect는 컴포넌트가 처음 렌더링된 후, 
의존성 배열의 값이 변경될 때, 
컴포넌트가 언마운트될 때 호출됩니다.

참고 Reference: https://www.maeil-mail.kr/question/64


- 자바스크립트는 싱글 스레드 언어인데 어떻게 동시에 여러 작업을 수행하나요?
자바스크립트는 싱글 스레드 언어라, 한 번에 하나의 작업만을 처리할 수 있는 단일 콜 스택을 가집니다.
하지만 브라우저나 Node.js 환경이 제공하는 비동기 처리 메커니즘 덕분에 여러 작업을 동시에 수행할 수 있습니다.

자바스크립트는 브라우저의 WebAPI나 Node의 libuv, 이벤트 루프, 태스크 큐를 이용해
비동기 작업을 동시에 처리합니다.
비동기 작업이 발생하면, 해당 작업은 브라우저의 WebAPI에 위임됩니다. 
예를 들어, setTimeout이나 fetch 같은 작업이 수행되면 
자바스크립트 엔진은 이 작업들을 Web API에게 넘기고 다른 코드 실행을 이어갑니다.
Web API에서 비동기 작업이 완료되면, 그 작업은 태스크 큐에 들어가 대기합니다.

이후 이벤트 루프가 콜 스택이 비어있는지 확인한 두
태스크 큐에서 대기 중인 작업을 콜 스택으로 가져와 실행합니다.
이런 구조 덕분에 JS는 비동기적으로 작업을 처리하여 싱글 스레드임에도 다양한 작업을 효율적으로 관리할 수 있습니다.
이 메커니즘 덕분에 UI인터랙션이 끊기지 않으며 
대기시간이 필요한 작업도 동시에 실행되는 것과 같이 동작하게 됩니다.

* 태스크 큐: 
JS의 태스크 큐는 크게 매크로태스크 큐와 마이크로태스크 큐로 나뉜다.
이 queue들은 비동기 작업의 우선순위를 관리하고 
이벤트 루프가 적절한 시점에 콜백을 사용하기 위해 사용된다.

1. 매크로태스크 큐 : 일반적인 비동기 작업의 콜백이 저장되는 큐.
setTimeout, setInterval, I/O작업, 이벤트 핸들러 등은 
작업 완료 후 매크로태스크 큐에 콜백을 대기시킨다.
매크로태스크 큐는 이벤트 루프가 한 번 반복될 때마다 하나의 태스크만 처리되므로
UI업데이트나 다른 작업과 균형있게 진행된다.
2. 마이크로태스크 큐 : 더 높은 우선순위가 필요한 비동기 작업들이 대기하는 큐.
Promise.then, MutationObserver 등의 비동기 콜백이 마이크로태스크 큐에 저장된다.
이벤트 루프는 macrotask를 실행하기 전에 "항상" microtask queue를 먼저 확인하고
모든 마이크로태스크를 처리한 다음
매크로태스크로 넘어간다.
이러한 방식을 통해 마이크로태스크 큐의 작업은 "높은 우선순위"로 처리된다.
참고 Reference : https://www.maeil-mail.kr/question/57
