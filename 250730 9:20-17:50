# LLM : Large Language Model
# 대규모 데이터를 기반으로 학습된 초거대 '언어 모델'로,
# 자연어 생성, 번역, 요약 등 다양한 '언어'관련 작업을 수행할 수 있는 딥러닝 모델이다.

# 가장 근본적인 작업은 "다음에 올 단어 예측하기"

# 트랜스포머 아키텍처, 어텐션 매커니즘 : Transformer - Attention Mechanism
# 인간이 학습하는 과정에서도 모든 단어를 기억하지 않고(모든 것을 다 동일한 비중으로 기억하는 게 아니라)
# 형광펜으로 주요 단어를 밑줄치며 기억하는 등의 과정을 거칠 것임.
# Attention Mechanism은 그런 형광펜의 역할을 하는 매커니즘임. (파라미터가 너무 많기 때문에 점수를 부여해서 주요 단어 예측)

# 환각 Hallucination : 사실이 아닌 정보를 생성하는 것 - 학습 데이터의 불완전성, 과도한 일반화로 인해 발생
# -> 2차 검증이 필요하다

# 구글에 openai api 검색, 우측 상단 API 플랫폼 클릭, 로그인
# API 플랫폼 들어가서 우측 상단 Start building 누르고 Organization 만들 (I'll invite my team later 선택)
# Token 답변에 따라 비용이 측정됨. -> Max tokens를 적당히 작게 잡아야 비용이 덜 나감
# System message에 페르소나(e.g. '당신은 모든 답변을 해적처럼 말하는 유쾌한 AI 선장입니다.')
# User message에는 (아마도) User의 페르소나 설정 가능
# ChatGPT의 temperature(창의성?)은 0부터 2까지임. : 0으로 설정하면 최대한 방어적(보수적)으로 답변함
# 창의성이 낮을수록 예측가능한 일관적인, 사실 위주의 LLM : Large Language Model
# 대규모 데이터를 기반으로 학습된 초거대 '언어 모델'로,
# 자연어 생성, 번역, 요약 등 다양한 '언어'관련 작업을 수행할 수 있는 딥러닝 모델이다.

# 가장 근본적인 작업은 "다음에 올 단어 예측하기"

# 트랜스포머 아키텍처, 어텐션 매커니즘 : Transformer - Attention Mechanism
# 인간이 학습하는 과정에서도 모든 단어를 기억하지 않고(모든 것을 다 동일한 비중으로 기억하는 게 아니라)
# 형광펜으로 주요 단어를 밑줄치며 기억하는 등의 과정을 거칠 것임.
# Attention Mechanism은 그런 형광펜의 역할을 하는 매커니즘임. (파라미터가 너무 많기 때문에 점수를 부여해서 주요 단어 예측)

# 환각 Hallucination : 사실이 아닌 정보를 생성하는 것 - 학습 데이터의 불완전성, 과도한 일반화로 인해 발생
# -> 2차 검증이 필요하다

# 구글에 openai api 검색, 우측 상단 API 플랫폼 클릭, 로그인
# API 플랫폼 들어가서 우측 상단 Start building 누르고 Organization 만들 (I'll invite my team later 선택)
# Token 답변에 따라 비용이 측정됨. -> Max tokens를 적당히 작게 잡아야 비용이 덜 나감
# System message에 페르소나(e.g. '당신은 모든 답변을 해적처럼 말하는 유쾌한 AI 선장입니다.')
# User message에는 (아마도) User의 페르소나 설정 가능
# ChatGPT의 temperature(창의성?)은 0부터 2까지임. : 0으로 설정하면 최대한 방어적(보수적)으로 답변함
# 창의성이 낮을수록 예측가능한 일관적인, 사실 위주의 답변을 한다

# 지시사항을 구체적으로 할 수록 질 높은 결과를 얻게 된다.


1. VS code 확장 프로그램에서 'jupyter' 다운
2. .ipynb 파일 생성
3. 환경 설정 들어간 코드 run > ipykernel 설치하라고 나옴. 설치
4. %pip install openai run하면 커넬 선택(select kernel)하라고 나옴. > 미리 만들어뒀던 pythonstudy_env 환경 선택
5. .env 파일, .gitignore 파일 생성

16_LLM/02_prompt_engineering.ipynb
# Prompting Engineering w/ chatgpt
환경설정

%pip install openai

# OPENAI_API_KEY설정
import os
from dotenv import load_dotenv

load_dotenv() # 현재 경로의 .env 파일을 읽어 시스템 환경변수로 등록

OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')

#Chat Completion

from openai import OpenAI

#client-server 하나 설정
client = OpenAI(api_key=OPENAI_API_KEY)
# 나의 openai api키를 갖고 있는 클라이언트가 생성되었다.

response = client.chat.completions.create(
    model="gpt-4.1",
    messages=[
        {
            "role": "system", 
            "content": [
                {
                    # 타입과 텍스트(역할)를 다 전달해야함
                    "type": "text",
                    "text": "당신은 자상하고 친절한 챗봇입니다."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "content": [
                        {
                            "type": "text",
                            "text": "더운 날 점심으로 뭘 먹으면 좋을까요?"
                        }
                    ]
                }
            ]
        }
    ],
    response_format={
        'type': "text"
    },
    temperature=1.0, # 대답 창의성에 관한 설정(기본값: 1), 0~2까지 설정 가능
    max_tokens=2048, # 응답에 사용될 토큰 수(응답 최대토큰수)
    top_p=1, # 사용할 상위누적확률
    frequency_penalty=0, # 토큰 사용 빈도수에 대한 패널티
    presence_penalty=0 # 토큰 재사용에 대한 패널티
)

print(response.choices[0].message.content)

# 🚨에러!!
# 안녕하세요! 무엇을 도와드릴까요? 😊
# 라고만 뜸

# 원인 분석1. 코드가 잘못 됐나??
# -> 코드 비교
"role": "system", 
            "content": [
                {
                    # 타입과 텍스트(역할)를 다 전달해야함
                    "type": "text",
                    "text": "당신은 자상하고 친절한 챗봇입니다."
                }
            ]
이 구조와 다르게
 "role": "user",
            "content": [
                {
                    "type": "text",
                    "content": [
                        {
                            "type": "text",
                            "text": "더운 날 점심으로 뭘 먹으면 좋을까요?"
                        }
                    ]
                }
            ]
여기에서 두 번째 content 값이 중복 되는 거 같음.
"content": [
             {
               "type": "text",
               "text": "더운 날 점심으로 뭘 먹으면 좋을까요?"
             }
]
삭제하고 text 값만 "type" 아래에 넣음

# 수정 후
response = client.chat.completions.create(
    model="gpt-4.1",
    messages=[
        {
            "role": "system", 
            "content": [
                {
                    # 타입과 텍스트(역할)를 다 전달해야함
                    "type": "text",
                    "text": "당신은 자상하고 친절한 챗봇입니다."
                }
            ]
        },
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "더운 날 점심으로 뭘 먹으면 좋을까요?"
                }
            ]
        }
    ],
    response_format={
        'type': "text"
    },
    temperature=1.0, # 대답 창의성에 관한 설정(기본값: 1), 0~2까지 설정 가능
    max_tokens=2048, # 응답에 사용될 토큰 수(응답 최대토큰수)
    top_p=1, # 사용할 상위누적확률
    frequency_penalty=0, # 토큰 사용 빈도수에 대한 패널티
    presence_penalty=0 # 토큰 재사용에 대한 패널티
)

print(response.choices[0].message.content)

# 저장 후 CTRL+ALT+ENTER로 실행
# 결과: -----------
더운 날에는 시원하고 가볍게 먹을 수 있는 음식이 좋겠죠! 이런 메뉴를 추천드려요:

1. **냉면** – 시원한 육수에 쫄깃한 면발이 더위를 싹 가셔줄 거예요.
2. **콩국수** – 고소하면서도 시원해서 부담 없이 즐길 수 있어요.
3. **비빔국수** – 매콤새콤하게 비벼 먹으면 입맛도 돌아와요.
4. **회덮밥** – 신선한 야채와 해산물이 들어가 깔끔하고 시원하게 즐길 수 있습니다.
5. **샐러드와 샌드위치** – 가볍고 소화도 잘돼서 좋답니다.

음료로는 아이스커피, 시원한 식혜, 얼음 동동 띄운 오미자차도 추천드려요!  
오늘 점심 맛있게 드시고, 더위도 잘 이겨내시길 바랄게요😊
# -----------


# 패턴 1: 페르소나 & Few-Shot(기사 제목 교정)
## 기자들이 송고한 제목에서 맞춤법, 의미, 어조 등의 교정작업을 수행한다.
## (프랑스 AFP시스템에서 최초 적용)

from openai import OpenAI

# 이번에는 함수형태로 변경해 재사용성을 높인다.
def correct_title (query, temperature=0.3):
    # 1. client 설정
    client=OpenAI(api_key=OPENAI_API_KEY)

    #2. system prompt를 변수에 할당
    #(들어가는 내용: 페르소나, 지켜야 할 규칙, Few-Shot예시)
    # 샵 3개는 굳이 안 넣어도 되지만 각 prompt의 구분을 위해 넣어주었다.
    system_instruction = """
    기자들이 송고한 제목, 즉 현재의 기사 제목을 교정해줘.
    
    ### 지시사항 ###
    - 기사의 제목이 명확하고 주제와 잘 맞도록 수정해주세요.
    - 독자의 관심을 끌 수 있도록 간결하고 임팩트있는 표현을 사용해주세요.
    - 비속어, 은어 등은 제거하고, 의미가 유지되도록 제목을 교정해주세요.

    ### 출력 형식 ###
    - 원래 제목: [기사의 원래 제목]
    - 교정한 제목: [기사의 교정된 제목]

    ### 예시 ###
    - 원래 제목: "어제 태국에서 총격 사건이 일어나서 시장에 있던 수많은 사람들이 대피했다."
    - 교정한 제목: "태국 시장 총격 사건, 수십명 대피"

    """

    user_msg = f"""
    다음 제목을 교정해주세요.
    제목: {query}
    """

    #def correct_title 안에 response가 들어갈 수 있도록 들여쓰기 한 칸 더 넣음
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[ 
            #대화의 히스토리를 리스트 형태로 전달. 각 요소는 role과 content를 가진 딕셔너리이다.
            {
                "role": "system", # 시스템의 전반적인 지시사항 전달. 대화의 가장 처음에 위치해 모델의 행동 기준을 설정함
                "content": [
                    {
                        # 타입과 텍스트(역할)를 다 전달해야함
                        "type": "text",
                        "text": system_instruction
                    }
                ]
            },
            {
                "role": "user",  # 사용자의 실제 요청 전달
                "content": [
                    {
                        "type": "text",
                        "text": user_msg
                    }
                ]
            }
        ],
        response_format={
            'type': "text"
        },
        temperature=temperature, # 대답 창의성에 관한 설정(기본값: 1), 0~2까지 설정 가능
        max_tokens=2048, # 응답에 사용될 토큰 수(응답 최대토큰수)
        top_p=1, # 사용할 상위누적확률
        frequency_penalty=0, # 토큰 사용 빈도수에 대한 패널티
        presence_penalty=0 # 토큰 재사용에 대한 패널티
    )
    return response.choices[0].message.content

print(correct_title('이은지의 FM 개꿀 라디오 방송에 주목해주세요~!'))
print(correct_title('미친 물난리로 졸라 고생하는 한국 공무원들에게 보상이 이뤄져야한다.')) # 교정이 제대로 되는지 확인 위해 일부러 비속어와 은어를 넣음.

# 결과: ----------
- 원래 제목: 이은지의 FM 개꿀 라디오 방송에 주목해주세요~!
- 교정한 제목: 이은지의 FM 라디오, 청취자 관심 집중
- 원래 제목: 미친 물난리로 졸라 고생하는 한국 공무원들에게 보상이 이뤄져야한다.
- 교정한 제목: 폭우 피해 대응한 한국 공무원, 합당한 보상 필요
# ----------------


# 다음과 같이 system instuction을 바꾸면 또 다른 답변이 출력된다.
system_instruction = """
    기자들이 송고한 제목, 즉 현재의 기사 제목을 교정해줘.
    
    ### 지시사항 ###
    - 기사의 제목이 명확하고 주제와 잘 맞도록 수정해주세요.
    - 독자의 관심을 끌 수 있도록 간결하고 임팩트있는 표현을 사용해주세요.
    - 비속어, 은어 등은 제거하고, 의미가 유지되도록 제목을 교정해주세요.

    ### 출력 형식 ###
    - 원래 제목: [기사의 원래 제목]
    - 교정한 제목: 
        [기사의 교정된 제목1]
        [기사의 교정된 제목2]
        [기사의 교정된 제목3]

    ### 예시 ###
    - 원래 제목: "어제 태국에서 총격 사건이 일어나서 시장에 있던 수많은 사람들이 대피했다."
    - 교정한 제목: 
        "태국 시장 총격 사건, 수십명 대피"
        "태국 시장 총격 사건, 충격"
        "태국에서 충격적인 총격 사건 발생"

    """

# 결과: ----------
- 원래 제목: 이은지의 FM 개꿀 라디오 방송에 주목해주세요~!
- 교정한 제목: 
    "이은지의 FM 라디오, 청취자 관심 집중"
    "이은지, 새 FM 라디오 방송으로 주목"
    "이은지의 FM 라디오, 기대감 높아져"
- 원래 제목: 미친 물난리로 졸라 고생하는 한국 공무원들에게 보상이 이뤄져야한다.
- 교정한 제목: 
    "폭우 피해 대응한 한국 공무원, 정당한 보상 필요"
    "폭우 속 헌신한 공무원들, 보상 대책 마련 시급"
    "물난리 대응 공무원, 합당한 보상 이뤄져야"
# ---------------

from openai import OpenAI
import json

# 함수 선언형으로 재사용성 높인 코드 작성
def extract_eng_words(query, temperature=0.5):
    client = OpenAI(api_key=OPENAI_API_KEY)

    system_instruction="""
    당신은 영어팝송을 이용해 흥미롭고 이해하기 쉬운 방식으로 영어를 가르치는 선생님입니다.

    # 처리단계
    1. 주어진 팝송 가사에서 자주 사용되는 영어단어 3개를 무작위로 추출해줘.
    2. 각 단어의 품사와 의미를 한글로 알려줘.
    
    # 출력형식
    - 출력형식은 json 형식입니다.

    # 출력예시
    {
        "json_list": [
            {
                "빈출 단어 3가지" : "yesterday", "love", "you"               
            },
            {
                "단어" : "yesterday"
                "품사와 의미" : "명사 - 어제" 
            },
            {
                 "단어" : "love"
                "품사와 의미" : "명사 혹은 동사 - 사랑, 사랑하다" 
            },
            {
                 "단어" : "you"
                "품사와 의미" : "명사 - 너, 당신" 
            }
        ]
    }
    """

    user_msg = f"""
    노래 가사: {query}
    """

    #def correct_title 안에 response가 들어갈 수 있도록 들여쓰기 한 칸 더 넣음
    response = client.chat.completions.create(
        model="gpt-4.1",
        messages=[ 
            #대화의 히스토리를 리스트 형태로 전달. 각 요소는 role과 content를 가진 딕셔너리이다.
            {
                "role": "system", # 시스템의 전반적인 지시사항 전달. 대화의 가장 처음에 위치해 모델의 행동 기준을 설정함
                "content": [
                    {
                        # 타입과 텍스트(역할)를 다 전달해야함
                        "type": "text",
                        "text": system_instruction
                    }
                ]
            },
            {
                "role": "user",  # 사용자의 실제 요청 전달
                "content": [
                    {
                        "type": "text",
                        "text": user_msg
                    }
                ]
            }
        ],
        response_format={
            #이번에는 text 형태로 받는 게 아니라 json 형태로 받기 때문에 "text"에서 수정 필요
            # 응답의 content는 반드시 JSON 객체 형식의 문자열이어야한다고 명시적으로 요구
            'type': "json_object"
        },
        temperature=temperature, # 대답 창의성에 관한 설정(기본값: 1), 0~2까지 설정 가능
        max_tokens=2048, # 응답에 사용될 토큰 수(응답 최대토큰수)
        top_p=1, # 사용할 상위누적확률
        frequency_penalty=0, # 토큰 사용 빈도수에 대한 패널티
        presence_penalty=0 # 토큰 재사용에 대한 패널티
    )
    return json.loads(response.choices[0].message.content) # 응답 json 문자열을 파이썬 객체로 변환

lyrics = """
No clouds in my stones
Let it rain, I hydroplane in the bank
Comin' down with the Dow Jones
When the clouds come, we go, we Roc-A-Fella 
We fly higher than weather, in G5's or better
You know me (You know me)
In anticipation for precipitation, stack chips for the rainy day
Jay, Rain Man is back
With Little Miss Sunshine, Rihanna, where you at?

You have my heart, and we'll never be worlds apart
May be in magazines but you'll still be my star
Baby, 'cause in the dark, you can't see shiny cars
And that's when you need me there
With you, I'll always share because

When the sun shine, we shine together
Told you I'll be here forever
Said "I'll always be your friend"
Took an oath, I'ma stick it out 'til the end
Now that it's rainin' more than ever
Know that we'll still have each other
You can stand under my umbrella
"""

print(extract_eng_words(lyrics))

# 결과: ----------
{'json_list': [{'빈출 단어 3가지': ['rain', 'shine', 'together']}, {'단어': 'rain', '품사와 의미': '명사 혹은 동사 - 비, 비가 오다'}, {'단어': 'shine', '품사와 의미': '동사 - 빛나다, 빛을 내다'}, {'단어': 'together', '품사와 의미': '부사 - 함께, 같이'}]}
# ---------------
