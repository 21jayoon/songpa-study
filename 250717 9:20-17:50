# 20250717 Developing Day 9
## 1. Question: Can I move two constants in JwtFilter into ApiResponse(enum)?
No, you should **not** move `AUTHORIZATION_HEADER` and `BEARER_PREFIX` into your `ApiResponse` enum.

Here's why:

---

### Separation of Concerns

The `ApiResponse` enum is designed to handle **API response messages and HTTP status codes**, specifically for various outcomes of your CRUD operations (like successful user modification, registration, or error conditions). It's all about defining the *payload* and *status* of a response.

The constants `AUTHORIZATION_HEADER` and `BEARER_PREFIX`, on the other hand, are related to **how authentication tokens are transmitted in HTTP request headers**. They are part of the *protocol* or *mechanism* for security, not the *content* of an API response.

Mixing these distinct concerns would make your `ApiResponse` enum:
* **Less intuitive**: A developer looking at `ApiResponse` would expect to find messages related to API outcomes, not HTTP header names.
* **Less reusable**: These authentication constants have no direct relevance to other parts of your API responses.
* **Harder to maintain**: If you need to change how authorization headers are structured, you'd be modifying a file that primarily deals with response messages, which is confusing.

---

### Best Practice for Constants

It's a good practice to keep constants relevant to a specific domain within their respective classes or in a dedicated constants file if they are widely used across multiple, closely related classes.

In your current setup, having them directly in `JwtAuthenticationFilter` is perfectly fine because they are **specific to the context of JWT authentication and how the filter processes incoming requests**.

---

### Recommendation

Keep `AUTHORIZATION_HEADER` and `BEARER_PREFIX` exactly where they are, within the `JwtAuthenticationFilter` class. This maintains a clear separation of concerns and makes your code more organized and easier to understand.

## 2. Complete UserController (maybe)

    package com.header.header.domain.user.controller;

    import com.header.header.auth.model.dto.SignupDTO;
    import com.header.header.domain.user.dto.UserDTO;
    import com.header.header.domain.user.facade.UserFacadeService;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.*;
    import org.springframework.web.servlet.ModelAndView;
    
    @Controller
    @RequestMapping("/auth")
    public class UserController {
    private final UserFacadeService userFacadeServiceService;
    
        public UserController(UserFacadeService userFacadeServiceService) {
            this.userFacadeServiceService = userFacadeServiceService;
        }
    
        @GetMapping("/users")
        public void signup(){
            //void = user/signup으로 (자동) 반환
        }
    
        //post 요청 받아줄 핸들러 메소드 작성
        @PostMapping("/users")
        public ModelAndView signup(ModelAndView mv, @ModelAttribute SignupDTO signupDTO){
            //@ModelAttribute SignupDTO signupDTO ->
            // 원래는 signupDTO가 유효성에 부합하는지도 확인해야함.
            //그러나 이번엔 간단하게 바로 DTO 적용하는 걸로.
    
            int result = userFacadeServiceService.registerUser(signupDTO);
    
            String msg = "";
    
            if(result >0){
                msg = "Successfully Signed up";
                mv.setViewName("auth/session.html");
                // 회원가입 성공 시 로그인 페이지로 이동
            }else {
                msg="Fail to sign up";
                mv.setViewName("auth/users");
                //실패 시 회원가입 form("auth/users")으로 다시 돌아오도록 설정
            }
            //signup 페이지 <header> <script> 내에 메세지 alert 뜨도록 작성
            mv.addObject("msg", msg);
    
            return mv;
        }
    
        @GetMapping("/session")
        public void login() {
        }
    
        //로그인 실패시 핸들해줄 핸들러 메소드 작성
        @GetMapping("/session/fail")
        public ModelAndView loginFail(ModelAndView mv,
                                      @RequestParam(value = "msg"
                                              , defaultValue = "login failed") String msg) {
            //@RequestParam을 통해 어떤 실패가 일어난 건지 메시지 받는다.
            mv.addObject("msg", msg);
            mv.setViewName("/auth/fail");
            return mv;
        }
    //spring-security-architecture에서 실제 인증이 일어난다
    
        // 회원정보 수정 시
        @GetMapping("/auth/{user_id}")
        public void modifyUser(){}
    
        @PutMapping("/auth/{user_id}")
        public String modifyUser(@ModelAttribute UserDTO userDTO) {
            userFacadeServiceService.updateUser(userDTO);
            return "redirect:/session";
        }
    
        // 회원탈퇴 시
        @GetMapping("/auth/{user_id}/leave")
        public void leaveHeader() {}
    
        //회원탈퇴 시 patchmapping 이용해서 isAdmin 변경
        @PatchMapping("/auth/{user_id}/leave")
        public String leaveHeader(@ModelAttribute UserDTO userDTO) {
            userFacadeServiceService.withdrawUser(userDTO);
            return "redirect:/";
        }
    }

## 3. Copy and paste the lecture source and edit little

    package com.header.header.auth.config;
    ......

    import java.security.Key;
    import java.util.*;
    import java.util.stream.Collectors;

    /*
    * 설명. JWT(Json Web Token)의 구조 (https://jwt.io/introduction)
    *  ====================================================================================================
    *  1. 헤더(Header)
    *    - typ: 토큰의 타입 지정(JWT)
    *    - alg: 해싱 알고리즘으로 Verify Signature에서 사용 됨
    *  ====================================================================================================
    *  2. 내용 또는 정보(Payload)
    *    - 토큰에 담을 정보가 들어 있음
    *    - 담는 정보의 한 조각을 클레임(claim - name과 value의 쌍으로 구성)이라 부름
    *      a. 등록된 클레임(registered claim)
    *         : 토큰에 대한 정보가 담김
    *            iss: 토큰 발급자(issuer)
    *            sub: 토큰 제목(subject)
    *            aud: 토큰 대상자(audience)
    *            exp: 토큰의 만료 시간(expiration)
    *            nbf: 토큰 활성화(발급) 날짜(not before)
    *            iat: 토큰 활성화(발급) 시간(issued at)
    *      b. 공개 클레임(public claim)
    *         : 사용자 정의 클레임으로 공개용 정보를 위해 사용(충돌 방지를 위해 URI로 구성)
    *      c. 비공개 클레임(private claim)
    *         : 사용자 정의 클레임으로 서버(JWT 발급자)와 클라이언트 사이에 임의로 지정한 정보를 저장
    *           (충돌 발생 우려가 있으니 조심해서 사용할 것)
    *  ====================================================================================================
    *  3. 서명(Verify Signature)
    *    - Header 인코딩 값과 Payload 인코딩 값을 합쳐서 비밀 키로 해쉬(헤더의 해싱 알고리즘으로)하여 생성
    * */

    /* 설명.
    *  토큰 생성, 토큰 유효성 검사, 토큰 인증(Authentication 객체 반환)
    *  (참고: 아래 5가지 메소드가 존재하는데, 각 메소드마다 주석으로 붙여놓은 번호가 존재한다.
    *  이 번호는 동작 순서가 아니라 그저 코드를 작성한 순서일 뿐이니, 복습할 때 주의하자.)
    * */
    @Component
    public class TokenProvider {

      private static final Logger log = LoggerFactory.getLogger(TokenProvider.class);
      private static final String AUTHORITIES_KEY = "auth";
      private static final String BEARER_TYPE = "bearer";
      private static final long ACCESS_TOKEN_EXPIRE_TIME = 1000 * 60 * 30;

      // Spring Security가 제공하는 UserDetailsService를 그대로 활용
      private final UserDetailsService userDetailsService;

      // java.security.Key로 import 할 것
      private final Key key;

      /* 설명: @Value
        *  스프링이 관리하는 빈(bean)에서 프로퍼티 값들을 주입받기 위한 어노테이션.
        *  이 어노테이션은 필드 값, 생성자 인자, 메소드 인자에 사용되며,
        *  SpringBoot의 설정 파일(application.yaml)로부터 값을 읽어와 주입한다.
        *  주입할 값은 스프링 Expression Language (SpEL) or 프로퍼티 키를 사용해 런타임에 설정 가능하다.
        *  이를 통해 설정 파일에서 관리하는 프로퍼티 값을 소스 코드로 불러와 직접 사용할 수 있게 된다.
        * */
          public TokenProvider(UserDetailsService userDetailsService,
          @Value("${jwt.secret}") String secretKey) {

          // UserDetailsService 인스턴스를 클래스 필드에 할당.
          this.userDetailsService = userDetailsService;
          // 이후, 전달된 secretKey를 Base64 디코딩해서 JWT 서명에 사용할 Key 객체를 생성 및 초기화.
          byte[] keyBytes = Decoders.BASE64.decode(secretKey);
          this.key = Keys.hmacShaKeyFor(keyBytes);
          }

      /* 목차. 1. 토큰 생성 메서드 */
      public TokenDTO generateTokenDTO(User member) {

           log.info("[TokenProvider] generateTokenDTO() Start");

           // 매개변수로 전달된 회원의 권한을 담기 위한 리스트 생성
           List<String> roles = new ArrayList<>();
           // 회원의 권한을 모두 추출해 리스트에 추가
           for(MemberRole memberRole : member.getMemberRole()) {
               roles.add(memberRole.getAuthority().getAuthorityName());
           }

           log.info("[TokenProvider] authorized authorities {}", roles);

           // 현재 시간(msec)
           long now = System.currentTimeMillis();
           // 위에서 밀리초로 구해놓은 현재 시간에 토큰 만료 시간을 더해 유효 기간을 설정
           Date accessTokenExpiresIn = new Date(now + ACCESS_TOKEN_EXPIRE_TIME);

           // JWT 토큰 생성
           String accessToken = Jwts.builder()
                   // 회원 아이디를 "sub"이라는 클레임으로 토큰에 추가
                   .setSubject(member.getUserId())
                   // 회원의 권한들을 "auth"라는 클레임으로 토큰에 추가
                   .claim(AUTHORITIES_KEY, roles)
                   // 만료 시간 설정
                   .setExpiration(accessTokenExpiresIn)
                   // 서명 및 알고리즘 설정
                   .signWith(key, SignatureAlgorithm.HS512)
                   // 압축 = header + payload + signature
                   .compact();
           System.out.println("조립된 accessToken 확인 = " + accessToken);

           log.info("[TokenProvider] generateTokenDTO() End");

           return new TokenDTO(BEARER_TYPE, member.getUserName(), accessToken, accessTokenExpiresIn.getTime());
      }

      /* 목차. 2. 토큰에 등록된 클레임의 sub에서 해당 회원의 아이디를 추출 */
      public String getUserId(String token) {

           return Jwts.parserBuilder()
                   // 서명 키 설정
                   .setSigningKey(key)
                   // 파서 빌드
                   .build()
                   // JWT 토큰을 파싱하여 Claims Jws 객체로 변환
                   .parseClaimsJws(token)
                   // payload의 Claims 추출
                   .getBody()
                   // Claims 중에 등록 클레임에 해당하는 sub값 추출(회원 아이디)
                   .getSubject();
      }

      /* 목차. 3. AccessToken으로 인증 객체 추출(이 클래스의 5번과 2번에 해당하는 메서드를 사용) */
      public Authentication getAuthentication(String token) {

           log.info("[TokenProvider] getAuthentication() Start");

           // 매개변수로 전달된 토큰에서 claim들 추출(토큰 복호화)
           Claims claims = parseClaims(token);		// 아래 5번에서 만든 메소드

           // 권한 정보가 없는 토큰에 대한 예외 처리
           if (claims.get(AUTHORITIES_KEY) == null) {
               throw new RuntimeException("권한 정보가 없는 토큰입니다.");
           }

           // 클레임에서 권한 정보(auth) 추출
           Collection<? extends GrantedAuthority> authorities =
                   // ex: "ROLE_ADMIN"이랑 "ROLE_MEMBER"같은 문자열이 들어있는 문자열 배열
                   Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
                           // 문자열 배열에 들어있는 권한 문자열 마다 SimpleGrantedAuthority 객체로 변환
                           .map(role -> new SimpleGrantedAuthority(role))
                           // List<SimpleGrantedAuthority>로 수집.
                           .collect(Collectors.toList());

           log.info("[TokenProvider] authorized authorities {}", authorities);

           // Spring Security에서 제공하는 UserDetailsService를 이용해 사용자 정보를 로드
           // 이 때, UserDetailsService를 구현한 서비스 클래스를 생성해야 한다.
           UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUserId(token));

           log.info("[TokenProvider] getAuthentication() End");

           return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());
      }

      /* 목차. 4. 토큰 유효성 검사 */
      public boolean validateToken(String token) {
      try {
      Jwts.parserBuilder()
      .setSigningKey(key)
      .build()
      .parseClaimsJws(token);
      return true;
      } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {
      log.info("[TokenProvider] 잘못된 JWT 서명입니다.");
      throw new TokenException("잘못된 JWT 서명입니다.");
      } catch (ExpiredJwtException e) {
      log.info("[TokenProvider] 만료된 JWT 토큰입니다.");
      throw new TokenException("만료된 JWT 토큰입니다.");
      } catch (UnsupportedJwtException e) {
      log.info("[TokenProvider] 지원되지 않는 JWT 토큰입니다.");
      throw new TokenException("지원되지 않는 JWT 토큰입니다.");
      } catch (IllegalArgumentException e) {
      log.info("[TokenProvider] JWT 토큰이 잘못되었습니다.");
      throw new TokenException("JWT 토큰이 잘못되었습니다.");
      }
      }

      /* 목차. 5. AccessToken에서 클레임을 추출하는 메서드 */
      private Claims parseClaims(String token) {
      try {
      return Jwts.parserBuilder()
      .setSigningKey(key)
      .build()
      .parseClaimsJws(token)
      .getBody();
      } catch (ExpiredJwtException e) {
      /* 설명. 토큰이 만료되어 예외가 발생하더라도 클레임 값들은 뽑을 수 있다. */
      return e.getClaims();
      }
      }
    }

    package com.header.header.auth.exception;

    public class TokenException extends RuntimeException{
    public TokenException(String message) {
        super(message);
        }
    }

    package com.header.header.auth.model.dto;

    public class TokenDTO {
    
        private String grantType;			// 토큰 타입
        private String memberName; 			// 인증받은 회원 이름
        private String accessToken; 		// 액세스 토큰
        private Long accessTokenExpiresIn;	// Long 형의 만료 시간
    
        public TokenDTO() {
        }
        public TokenDTO(String grantType, String memberName, String accessToken, Long accessTokenExpiresIn) {
            this.grantType = grantType;
            this.memberName = memberName;
            this.accessToken = accessToken;
            this.accessTokenExpiresIn = accessTokenExpiresIn;
        }
    
        public String getGrantType() {
            return grantType;
        }
    
        public void setGrantType(String grantType) {
            this.grantType = grantType;
        }
    
        public String getMemberName() {
            return memberName;
        }
    
        public void setMemberName(String memberName) {
            this.memberName = memberName;
        }
    
        public String getAccessToken() {
            return accessToken;
        }
    
        public void setAccessToken(String accessToken) {
            this.accessToken = accessToken;
        }
    
        public Long getAccessTokenExpiresIn() {
            return accessTokenExpiresIn;
        }
    
        public void setAccessTokenExpiresIn(Long accessTokenExpiresIn) {
            this.accessTokenExpiresIn = accessTokenExpiresIn;
        }
    
        @Override
        public String toString() {
            return "TokenDTO{" +
                    "grantType='" + grantType + '\'' +
                    ", memberName='" + memberName + '\'' +
                    ", accessToken='" + accessToken + '\'' +
                    ", accessTokenExpiresIn=" + accessTokenExpiresIn +
                    '}';
        }
    }

## 4. Since there's no either tbl_member_role or MemberRole entity, revise generateTokenDTO in TokenProvider
(Now)

    /* 목차. 1. 토큰 생성 메서드 */
    public TokenDTO generateTokenDTO(User member) {

        log.info("[TokenProvider] generateTokenDTO() Start");

        // Get authorities directly from AuthDetails (which is a UserDetails object)
        // Map GrantedAuthority objects to their string representations
        List<String> roles = authDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList());

        log.info("[TokenProvider] authorized authorities {}", roles);

        // 현재 시간(msec)
        long now = System.currentTimeMillis();
        // 위에서 밀리초로 구해놓은 현재 시간에 토큰 만료 시간을 더해 유효 기간을 설정
        Date accessTokenExpiresIn = new Date(now + ACCESS_TOKEN_EXPIRE_TIME);

        // JWT 토큰 생성
        String accessToken = Jwts.builder()
                .setSubject(authDetails.getUsername()) // 회원 이름을 "sub"이란 클레임으로 토큰에 추가
                .claim(AUTHORITIES_KEY, String.join(",", roles)) // A회원의 권한들을 "auth"라는 클레임으로 토큰에 추가
                .setExpiration(accessTokenExpiresIn)   // 만료 시간 설정
                .signWith(key, SignatureAlgorithm.RS256) // 서명 및 알고리즘 설정: 현재 갖고 있는 key를 이용해 로그인한다
                // 압축 = header + payload + signature
                .compact();

        System.out.println("조립된 accessToken 확인 = " + accessToken);

        log.info("[TokenProvider] generateTokenDTO() End");

        return new TokenDTO(BEARER_TYPE, member.getUserName(), accessToken, accessTokenExpiresIn.getTime());
    }


(Before)

    /* 목차. 1. 토큰 생성 메서드 */
    public TokenDTO generateTokenDTO(User member) {

        log.info("[TokenProvider] generateTokenDTO() Start");

        // 매개변수로 전달된 회원의 권한을 담기 위한 리스트 생성
        List<String> roles = new ArrayList<>();
        // 회원의 권한을 모두 추출해 리스트에 추가
        for(MemberRole memberRole : member.getMemberRole()) {
            roles.add(memberRole.getAuthority().getAuthorityName());
        }

## 5. Difference of ** and * in URL matching

### 1\. `*` (Single Asterisk): "Anything in the *next room* on this floor"

* **Meaning:** The `*` matches **zero or more characters within a single path segment**.
* **What it DOESN'T match:** It *does not* match the path separator (`/`). This means it will only match the "next level" directly under the specified path.
* **Example:** If you have `/auth/*`
    * **Matches:**
        * `/auth/login`
        * `/auth/register`
        * `/auth/session`
        * `/auth/logout`
    * **DOES NOT Match:**
        * `/auth/users/123` (Because `users/123` is *two* segments after `/auth/`)
        * `/auth/some/other/path`

-----

### 2\. `**` (Double Asterisk): "Anything *anywhere* down this hallway, no matter how many rooms deep"

* **Meaning:** The `**` matches **zero or more characters across multiple path segments**.
* **What it DOES match:** It *does* match the path separator (`/`). This means it will match anything that comes after the specified path, regardless of how many slashes (`/`) are in between.
* **Important Note:** `**` is typically used at the **end** of a path pattern.
* **Example:** If you have `/auth/**`
    * **Matches:**
        * `/auth/login`
        * `/auth/register`
        * `/auth/session`
        * `/auth/logout`
        * `/auth/users/123`
        * `/auth/users/delete/456`
        * `/auth/any/kind/of/path/you/can/imagine/here`
    * **DOES NOT Match:** (nothing in this pattern if it starts with `/auth/`)

-----

### Which Syntax Should You Use?

It depends on what you want to achieve:

* **Use `*` (`/auth/*`) when:**

    * You want to allow access only to direct "children" of a path.
    * You have a very flat URL structure and don't expect nested paths.
    * Example: If `/auth/login` and `/auth/register` are the only direct endpoints under `/auth` that you want to permit, but `/auth/users/123` should be protected differently.

* **Use `**` (`/auth/**`) when:**

    * You want to allow access to **all** paths that start with a certain prefix, no matter how deeply nested they are.
    * This is very common for APIs or static resources (like your `/public/**` example), where you want to apply a rule to an entire "branch" of your application.
    * **This is what your second professor is likely using for APIs.** Modern API design often involves nested URLs (e.g., `/api/users/1`, `/api/products/category/electronics`), and `**` makes it much easier to apply security rules to the entire `/api` "tree."

### In Your Specific Code:

```java
auth.requestMatchers("/auth/**", "/", "/main").permitAll();
```

In this line, `"/auth/**"` is used, which means:

* `/auth/session`
* `/auth/users`
* `/auth/session/fail`
* `/auth/login` (even though it's specifically permitted later, this general rule covers it)
* And any other path starting with `/auth/` like `/auth/some/deep/path/for/api`

...will all be accessible without authentication. This is generally a good choice for authentication-related endpoints, as they often have various sub-paths (like login, registration, password reset, etc.).

**In summary:**

* `*` = matches one level deep.
* `**` = matches any number of levels deep.

For most modern web applications and APIs, `**` is more frequently used when you want to broadly permit or restrict access to an entire section of your application's URLs.

## 6. Rephrase SecurityConfig

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .cors(withDefaults()) // CORS 설정은 그대로 유지 (예람님 코드에서 갖고 옴)
                // 세션 관리 전략을 STATELESS로 설정 (세션을 사용하지 않음)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                // 요청에 대한 권한 설정
                .authorizeHttpRequests(auth -> {
                    // 다음 경로들은 인증 없이 모든 사용자에게 허용
                    auth.requestMatchers("/auth/**", "/", "/main").permitAll();
                    // "/auth/login" (POST) 요청도 허용하여 로그인 시도를 가능하게 합니다.
                    auth.requestMatchers(HttpMethod.POST, "/auth/login").permitAll();
                    // "/my-shops/**" 경로는 ADMIN 역할만 접근 가능합니다.
                    auth.requestMatchers("/my-shops/**").hasRole("ADMIN");
                    // "/shops/**" 경로는 USER 역할만 접근 가능합니다.
                    auth.requestMatchers("/shops/**").hasRole("USER");
                    // 그 외 모든 요청은 인증된 사용자만 접근 가능합니다.
                    auth.anyRequest().authenticated();
                })
                // 폼 로그인 설정
                .formLogin(login -> {
                    login.loginPage("/auth/session"); // 로그인 페이지 URL
                    login.loginProcessingUrl("/auth/session"); // 로그인 처리 URL (POST 요청)
                    login.usernameParameter("userId");
                    login.passwordParameter("userPwd");
                    // 로그인 성공 시 LoginSuccessHandler를 사용합니다.
                    login.successHandler(new LoginSuccessHandler(jwtTokenProvider, objectMapper));
                    // 로그인 실패 시 AuthFailHandler를 사용합니다.
                    login.failureHandler(authFailHandler);
                })

                // 로그아웃 설정
                .logout(logout -> {
                    logout.logoutRequestMatcher(new AntPathRequestMatcher("/auth/logout", HttpMethod.POST.name())); // 로그아웃 요청 URL (POST)
                    // JWT는 세션을 사용하지 않으므로 JSESSIONID 삭제나 세션 무효화는 필요 없다.
                    // 로그아웃 성공 시 200 OK 상태 코드를 반환
                    logout.logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler());
                    logout.logoutSuccessUrl("/");
                })
                // 직접 작성한 커스텀 필터인 JwtAuthenticationFilter를 필터 체인에 추가 (이 필터는 모든 요청에서 JWT 토큰을 검증한다)
                .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class)
                
                .csrf(AbstractHttpConfigurer::disable)
                .formLogin(AbstractHttpConfigurer::disable)
                .httpBasic(AbstractHttpConfigurer::disable);

        return http.build();
    }

## 7. Study : SecutiryConfig code
csrf(AbstractHttpConfigurer::disable) 와 csrf(csrf -> csrf.disable()) 는 스프링 시큐리티에서 CSRF 보호 기능을 비활성화하는 두 가지 다른 방법입니다. 

두 방식 모두 동일한 결과를 가져오지만, 문법과 사용법에 약간의 차이가 있습니다.

* csrf(AbstractHttpConfigurer::disable)

메서드 참조 사용: 이 방식은 메서드 참조를 사용하여 AbstractHttpConfigurer 클래스의 disable() 메서드를 직접 호출합니다.

더 간결한 표현: 람다 표현식을 사용하지 않고 메서드 참조를 사용하므로 코드가 더 간결해 보입니다.

Spring Security 5.2.x 이상에서 권장: Spring Security 문서에서는 이 방식을 권장합니다.

* csrf(csrf -> csrf.disable()):

람다 표현식 사용: 이 방식은 람다 표현식을 사용하여 csrf 객체에 대해 disable() 메서드를 호출합니다.

더 유연한 설정 가능: 추후 CSRF 설정이 복잡해질 경우, 람다 표현식 내부에서 더 다양한 설정을 추가할 수 있습니다.

모든 Spring Security 버전에서 사용 가능: 이 방식은 모든 Spring Security 버전에서 사용 가능합니다.

결론:

두 방식 모두 CSRF 보호 기능을 비활성화하지만, 메서드 참조를 사용하는 csrf(AbstractHttpConfigurer::disable) 방식이

더 간결하고 Spring Security 5.2.x 이상에서 권장되는 방식입니다. 

그러나 람다 표현식을 사용하는 csrf(csrf -> csrf.disable()) 방식도 널리 사용되며, 

더 유연한 설정이 필요한 경우 유용합니다. 

어떤 방식을 선택하든, 프로젝트의 요구사항과 선호도에 따라 결정하면 됩니다.

## 8. Delete TokenProvider

    package com.header.header.auth.config;
    ......
    
    @Component
    public class TokenProvider {
    
        private static final Logger log = LoggerFactory.getLogger(TokenProvider.class);
        private static final String AUTHORITIES_KEY = "auth";
        private static final String BEARER_TYPE = "bearer";
        private static final long ACCESS_TOKEN_EXPIRE_TIME = 1000 * 60 * 30;
    
        // Spring Security가 제공하는 UserDetailsService를 그대로 활용
        private final UserDetailsService userDetailsService;
    
        private AuthDetails authDetails;
    
        // java.security.Key로 import 할 것
        private final Key key;
    
        /* 설명: @Value
         *  스프링이 관리하는 빈(bean)에서 프로퍼티 값들을 주입받기 위한 어노테이션.
         *  이 어노테이션은 필드 값, 생성자 인자, 메소드 인자에 사용되며,
         *  SpringBoot의 설정 파일(application.yaml)로부터 값을 읽어와 주입한다.
         *  주입할 값은 스프링 Expression Language (SpEL) or 프로퍼티 키를 사용해 런타임에 설정 가능하다.
         *  이를 통해 설정 파일에서 관리하는 프로퍼티 값을 소스 코드로 불러와 직접 사용할 수 있게 된다.
         * */
        public TokenProvider(UserDetailsService userDetailsService,
                             @Value("${jwt.secret}") String secretKey) {
    
            // UserDetailsService 인스턴스를 클래스 필드에 할당.
            this.userDetailsService = userDetailsService;
            // 이후, 전달된 secretKey를 Base64 디코딩해서 JWT 서명에 사용할 Key 객체를 생성 및 초기화.
            byte[] keyBytes = Decoders.BASE64.decode(secretKey);
            this.key = Keys.hmacShaKeyFor(keyBytes);
        }
    
        /* 목차. 1. 토큰 생성 메서드 */
        public TokenDTO generateTokenDTO(User member) {
    
            log.info("[TokenProvider] generateTokenDTO() Start");
    
            // Get authorities directly from AuthDetails (which is a UserDetails object)
            // Map GrantedAuthority objects to their string representations
            List<String> roles = authDetails.getAuthorities().stream()
                    .map(GrantedAuthority::getAuthority)
                    .collect(Collectors.toList());
    
            log.info("[TokenProvider] authorized authorities {}", roles);
    
            // 현재 시간(msec)
            long now = System.currentTimeMillis();
            // 위에서 밀리초로 구해놓은 현재 시간에 토큰 만료 시간을 더해 유효 기간을 설정
            Date accessTokenExpiresIn = new Date(now + ACCESS_TOKEN_EXPIRE_TIME);
    
            // JWT 토큰 생성
            String accessToken = Jwts.builder()
                    .setSubject(authDetails.getUsername()) // 회원 이름을 "sub"이란 클레임으로 토큰에 추가
                    .claim(AUTHORITIES_KEY, String.join(",", roles)) // A회원의 권한들을 "auth"라는 클레임으로 토큰에 추가
                    .setExpiration(accessTokenExpiresIn)   // 만료 시간 설정
                    .signWith(key, SignatureAlgorithm.RS256) // 서명 및 알고리즘 설정: 현재 갖고 있는 key를 이용해 로그인한다
                    // 압축 = header + payload + signature
                    .compact();
    
            System.out.println("조립된 accessToken 확인 = " + accessToken);
    
            log.info("[TokenProvider] generateTokenDTO() End");
    
            return new TokenDTO(BEARER_TYPE, member.getUserName(), accessToken, accessTokenExpiresIn.getTime());
        }
    
        /* 목차. 2. 토큰에 등록된 클레임의 sub에서 해당 회원의 아이디를 추출 */
        public String getUserId(String token) {
    
            return Jwts.parserBuilder()
                    // 서명 키 설정
                    .setSigningKey(key)
                    // 파서 빌드
                    .build()
                    // JWT 토큰을 파싱하여 Claims Jws 객체로 변환
                    .parseClaimsJws(token)
                    // payload의 Claims 추출
                    .getBody()
                    // Claims 중에 등록 클레임에 해당하는 sub값 추출(회원 아이디)
                    .getSubject();
        }
    
        /**
         * JWT 토큰으로부터 AccessToken으로 인증 정보를 추출합니다.
         * @param token JWT 토큰
         * @return 인증 객체 (Authentication)
         */
        public Authentication getAuthentication(String token) {
    
            log.info("[TokenProvider] getAuthentication() Start");
    
            // 매개변수로 전달된 토큰에서 claim들 추출(토큰 복호화)
            Claims claims = parseClaims(token);		// 아래 5번에서 만든 메소드
    
            // 권한 정보가 없는 토큰에 대한 예외 처리
            if (claims.get(AUTHORITIES_KEY) == null) {
                throw new RuntimeException("권한 정보가 없는 토큰입니다.");
            }
    
            // 클레임에서 권한 정보(auth) 추출
            Collection<? extends GrantedAuthority> authorities =
                    // ex: "ROLE_ADMIN"이랑 "ROLE_MEMBER"같은 문자열이 들어있는 문자열 배열
                    Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
                            // 문자열 배열에 들어있는 권한 문자열 마다 SimpleGrantedAuthority 객체로 변환
                            .map(role -> new SimpleGrantedAuthority(role))
                            // List<SimpleGrantedAuthority>로 수집.
                            .collect(Collectors.toList());
    
            log.info("[TokenProvider] authorized authorities {}", authorities);
    
            // Spring Security에서 제공하는 UserDetailsService를 이용해 사용자 정보를 로드
            // 이 때, UserDetailsService를 구현한 서비스 클래스를 생성해야 한다.
            UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUserId(token));
    
            log.info("[TokenProvider] getAuthentication() End");
    
            return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());
        }
    
        /* 토큰 유효성 검사 */
        public boolean validateToken(String token) {
            try {
                Jwts.parserBuilder()
                        .setSigningKey(key)
                        .build()
                        .parseClaimsJws(token);
                return true;
            } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {
                log.info("[TokenProvider] 잘못된 JWT 서명입니다.");
                throw new TokenException("잘못된 JWT 서명입니다.");
            } catch (ExpiredJwtException e) {
                log.info("[TokenProvider] 만료된 JWT 토큰입니다.");
                throw new TokenException("만료된 JWT 토큰입니다.");
            } catch (UnsupportedJwtException e) {
                log.info("[TokenProvider] 지원되지 않는 JWT 토큰입니다.");
                throw new TokenException("지원되지 않는 JWT 토큰입니다.");
            } catch (IllegalArgumentException e) {
                log.info("[TokenProvider] JWT 토큰이 잘못되었습니다.");
                throw new TokenException("JWT 토큰이 잘못되었습니다.");
            }
        }
    
        /* AccessToken에서 클레임을 추출하는 메서드 */
        private Claims parseClaims(String token) {
            try {
                return Jwts.parserBuilder()
                        .setSigningKey(key)
                        .build()
                        .parseClaimsJws(token)
                        .getBody();
            } catch (ExpiredJwtException e) {
                /* 토큰이 만료되어 예외가 발생하더라도 클레임 값들은 뽑을 수 있다. */
                return e.getClaims();
            }
        }
    }

## 9. onAuthenticationSuccess method inLoginSuccessHandler

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        // JWT 토큰을 생성합니다.
        String jwtToken = jwtTokenProvider.generateToken(authentication);

        // 응답 본문에 포함할 데이터를 구성합니다.
        Map<String, Object> responseBody = new HashMap<>();
        responseBody.put("message", "로그인 성공");
        responseBody.put("token", jwtToken); // 생성된 JWT 토큰을 응답에 포함

        // 응답 헤더 설정
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");
        response.setStatus(HttpServletResponse.SC_OK); // HTTP 상태 코드 200 OK

        // 응답 본문에 JSON 데이터를 작성합니다.
        objectMapper.writeValue(response.getWriter(), responseBody);

        // 클라이언트가 JWT를 쿠키에 저장하도록 하려면 다음 라인을 활성화하고,
        // HttpOnly 및 Secure 설정을 추가하여 보안을 강화할 수 있습니다.
        // Cookie jwtCookie = new Cookie("jwt_token", jwtToken);
        // jwtCookie.setHttpOnly(true); // JavaScript 접근 방지
        // jwtCookie.setSecure(true); // HTTPS 에서만 전송
        // jwtCookie.setPath("/"); // 모든 경로에서 쿠키 사용 가능
        // jwtCookie.setMaxAge((int) (JwtTokenProvider.getExpiration() / 1000)); // 만료 시간 설정 (초 단위)
        // response.addCookie(jwtCookie);
    }

## 10. [FRONT_END] modify main/layout.js
(Now)
    
    // 랜딩페이지 경로들 (사이드메뉴 없는 페이지들)
    const landingPaths = ['/', '/auth**'];

(Before)

     // 랜딩페이지 경로들 (사이드메뉴 없는 페이지들)
    const landingPaths = ['/', '/auth/session', '/auth/signup', "/auth/verification-code", "/auth/verification-code/validate"];
    const isLandingPage = landingPaths.includes(pathname);

## 11. [FRONT_END] Create Terms of Use checkbox
https://www.daleseo.com/react-checkboxes/

    function Checkbox({ children, disabled, checked, onChange }) {
        return (
            <label>
                <input
                type="checkbox"
                disabled={disabled}
                checked={checked}
                onChange={({ target: { checked } }) => onChange(checked)}
                />
            {children}
            </label>
        );
        }

    {/*회원가입 약관 체크*/}
                    <Checkbox checked={service} onChange={setService}>
                        (필수) 서비스 이용약관
                    </Checkbox>
                    <br/>
                    <Checkbox checked={marketing} onChange={setMarketing}>
                        (선택) 마케팅 수신
                    </Checkbox>
                    <br/>

## 12. [FRONT_END] Complete draft of session, signup, login, terms-of-use,verification-code, verification-code/validate

    "use client"; 
    import React from 'react';
    import styles from "../session/page.module.css";
    
    export default function Login() {
    return (
    <>
    <div className={styles.container}>
    
            <main className={styles.loginWrapper}>
              <div className={styles.loginContainer}>
                <form action="/shops" method="post" className={styles.loginForm}>
                  <div className={styles.inputGroup}>
                    <input
                      type="text"
                      name="id"
                      id="id"
                      placeholder="아이디"
                      required
                      className={styles.input}
                    />
                  </div>
    
                  {/* Password input group */}
                  <div className={styles.loginForm}>
                    <input
                      type="password"
                      name="password"
                      id="password"
                      placeholder="비밀번호"
                      required
                      className={styles.input}
                    />
                  </div>
    
                  {/* Error message display (will be dynamic in a real app) */}
                  <div id="error" className={`${styles.errorMessage} hidden`}>
                    <span></span>
                  </div>
    
                  {/* Login button */}
                  <button
                    type="submit"
                    className={styles.loginButton}
                  >
                    LOGIN
                  </button>
    
                  {/* Login links (회원가입, 아이디 찾기, 비밀번호 찾기) */}
                  <div className={styles.loginLinks}>
                    <a href="/auth/signup" className={styles.link}>회원가입</a>
                    <span className={styles.separator}>|</span>
                    <a href="/auth/id-retrieval" className={styles.link}>아이디 찾기</a>
                    <span className={styles.separator}>|</span>
                    <a href="/auth/password-reset" className={styles.link}>비밀번호 찾기</a>
                  </div>
                </form>
              </div>
            </main>
    
            {/* Footer section */}
            <footer className={styles.footer}>
            </footer>
          </div>
        </>
    );
    }

    .page {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    }
    
    .body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: #f2f2f2;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    }
    
    /* 로그인 페이지 전체 화면 중앙 정렬 */
    .container {
    min-height: calc(100vh - 120px); /* 헤더+푸터 높이 고려 */
    display: flex;
    justify-content: center; /* 수평 정렬 */
    min-height: 100vh;
    padding: var(--spacing-2xl);
    }
    
    
    /* Main Content */
    .main-content {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 40px 20px;
    }
    
    /* 로그인 박스 스타일 */
    .loginContainer {
    width: 100%;
    max-width: 400px;
    padding: var(--spacing-2xl);
    background-color: var(--background=#000);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
    }
    
    .login-form {
    display: flex;
    justify-content: center; /* 수평 정렬 */
    align-items: center;     /* 수직 정렬 */
    gap: 20px;
    }
    
    .input-group input {
    width: 100%;
    padding: 16px 20px;
    border: 2px solid #ddd;
    border-radius: 6px;
    font-size: 16px;
    transition: border-color 0.3s ease;
    background-color: #f2f2f2;
    }
    
    .input-group input:focus {
    outline: none;
    border-color: #2c3e50;
    background-color: white;
    }
    
    .input-group input::placeholder {
    color: #999;
    font-weight: 400;
    }
    
    .error-message {
    color: #e74c3c;
    font-size: 14px;
    text-align: center;
    margin-top: -10px;
    margin-bottom: 10px;
    }
    
    .login-button {
    width: 100%;
    padding: 18px;
    background-color: #13183d;
    color: white;
    border: none;
    border-radius: 6px;
    font-size: 18px;
    font-weight: bold;
    letter-spacing: 2px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    margin-top: 10px;
    }
    
    .login-button:hover {
    background-color: #34495e;
    }
    
    .login-button:active {
    transform: translateY(1px);
    }
    
    .login-links {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin-top: 20px;
    font-size: 14px;
    }
    
    .login-links .link {
    color: #666;
    text-decoration: none;
    transition: color 0.3s ease;
    }
    
    .login-links .link:hover {
    color: #2c3e50;
    text-decoration: underline;
    }
    
    .login-links .separator {
    color: #ccc;
    }
    
    .company-info {
    text-align: center;
    font-size: 12px;
    color: #666;
    line-height: 1.5;
    margin-bottom: 10px;
    }
    
    .company-info p {
    margin: 5px 0;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
    .login-container {
    margin: 20px;
    padding: 40px 30px;
    }

    .header-text {
        font-size: 20px;
    }
    
    .footer-links {
        flex-direction: column;
        gap: 5px;
    }
    
    .footer-links .separator {
        display: none;
    }
    
    .company-info {
        font-size: 11px;
    }
    }
    
    @media (max-width: 480px) {
        .login-container {
        padding: 30px 20px;
        }
    
        .input-group input {
            padding: 14px 16px;
            font-size: 15px;
        }
        
        .login-button {
            padding: 16px;
            font-size: 16px;
        }
    }

    "use client";
    import Link from 'next/link';
    import React, { useState } from 'react';
    import styles from "../signup/page.module.css";
    
    function Checkbox({ children, disabled, checked, onChange }) {
        return (
            <label>
                <input
                type="checkbox"
                disabled={disabled}
                checked={checked}
                onChange={({ target: { checked } }) => onChange(checked)}
                />
                {children}
            </label>
        );
    }
    
    export default function Signup() {
    const [service, setService] = React.useState(false);
    const [marketing, setMarketing] = React.useState(false);
    // State to manage form input values
    const [formData, setFormData] = useState({
    userName: '',
    userPhone: '',
    userId: '',
    userPwd: '',
    birthday: '',
    });
    
        // Handle input changes
        const handleChange = (e) => {
            const { name, value } = e.target;
            setFormData(prevData => ({
                ...prevData,
                [name]: value,
            }));
        };
    
        // Handle form submission
        const handleSubmit = async (e) => {
            e.preventDefault(); // Prevent default browser form submission
    
            // You would typically send this data to your backend
            console.log('Form submitted with data:', formData);
    
            try {
                const response = await fetch('/auth/signup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData),
                });
    
                if (response.ok) {
                    // Handle successful signup (e.g., redirect, show success message)
                    console.log('Signup successful!');
                    alert('회원가입이 성공적으로 완료되었습니다!');
                    // Example: Redirect to a login page
                    // window.location.href = '/login';
                } else {
                    // Handle errors (e.g., show error message)
                    const errorData = await response.json();
                    console.error('Signup failed:', errorData);
                    alert(`회원가입 실패: ${errorData.message || '알 수 없는 오류'}`);
                }
            } catch (error) {
                console.error('Error during signup:', error);
                alert('회원가입 중 오류가 발생했습니다. 다시 시도해주세요.');
            }
        };
    
        return (
            <div className="signup-container"> {/* Added a container for overall styling */}
                <h1>회원가입 페이지</h1>
                <div className="content-card">
                    <form onSubmit={handleSubmit}> {/* Use onSubmit for React forms */}
                        <div className="form-group">
                            <label htmlFor="userName">이름:</label>
                            <input
                                type="text"
                                id="userName"
                                name="userName"
                                value={formData.userName}
                                onChange={handleChange}
                                required // Add HTML5 validation
                            />
                        </div>
    
                        <div className="form-group">
                            <label htmlFor="userPhone">전화번호:</label>
                            <input
                                type="tel"
                                id="userPhone"
                                name="userPhone"
                                value={formData.userPhone}
                                onChange={handleChange}
                                placeholder="예: 010-1234-5678"
                                pattern="[0-9]{3}-?[0-9]{4}-?[0-9]{4}" // Basic pattern for phone number
                                required
                            />
                            <button type="submit">
                                <Link href="/auth/verification-code">전화번호 인증</Link>
                            </button>
                        </div>
    
                        <div className="form-group">
                            <label htmlFor="userId">아이디:</label>
                            <input
                                type="text"
                                id="userId"
                                name="userId"
                                value={formData.userId}
                                onChange={handleChange}                        
                                minLength="4" // Example: Minimum length for ID
                            />
                        </div>
    
                        <div className="form-group">
                            <label htmlFor="userPwd">비밀번호:</label>
                            <input
                                type="password"
                                id="userPwd"
                                name="userPwd"
                                value={formData.userPwd}
                                onChange={handleChange}
                                minLength="6" // Example: Minimum length for password
                            />
                        </div>
    
                        <div className="form-group">
                            <label htmlFor="birthday">생년월일:</label>
                            <input
                                type="date"
                                id="birthday"
                                name="birthday"
                                value={formData.birthday}
                                onChange={handleChange}
                            />
                        </div>
    
                        {/*회원가입 약관 체크*/}
                        <Checkbox checked={service} onChange={setService}>
                                (필수) 서비스 이용약관
                        </Checkbox>
                        <a class={styles.linkStyle} href="/auth/terms-of-use">
                            이용약관 보기
                        </a>
                        <br/>
                        <Checkbox checked={marketing} onChange={setMarketing}>
                            (선택) 마케팅 수신
                        </Checkbox>
                        <br/>
                        <button type="submit">회원가입</button>
                    </form>
                </div>
            </div>
        );
    }

    .linkStyle {
    color: #3b82f6;
    font-size: x-small;
    text-decoration: underline;
    text-underline-offset: 2px;
    }

    "use client"; 
    import React from 'react';
    import styles from "../session/page.module.css";
    
    export default function Login() {
    return (
    <>
    <div className={styles.container}>
    
            <main className={styles.loginWrapper}>
              <div className={styles.loginContainer}>
                <form action="/shops" method="post" className={styles.loginForm}>
                  <div className={styles.inputGroup}>
                    <input
                      type="text"
                      name="id"
                      id="id"
                      placeholder="아이디"
                      required
                      className={styles.input}
                    />
                  </div>
    
                  {/* Password input group */}
                  <div className={styles.loginForm}>
                    <input
                      type="password"
                      name="password"
                      id="password"
                      placeholder="비밀번호"
                      required
                      className={styles.input}
                    />
                  </div>
    
                  {/* Error message display (will be dynamic in a real app) */}
                  <div id="error" className={`${styles.errorMessage} hidden`}>
                    <span></span>
                  </div>
    
                  {/* Login button */}
                  <button
                    type="submit"
                    className={styles.loginButton}
                  >
                    LOGIN
                  </button>
    
                  {/* Login links (회원가입, 아이디 찾기, 비밀번호 찾기) */}
                  <div className={styles.loginLinks}>
                    <a href="/auth/signup" className={styles.link}>회원가입</a>
                    <span className={styles.separator}>|</span>
                    <a href="/auth/id-retrieval" className={styles.link}>아이디 찾기</a>
                    <span className={styles.separator}>|</span>
                    <a href="/auth/password-reset" className={styles.link}>비밀번호 찾기</a>
                  </div>
                </form>
              </div>
            </main>
    
            {/* Footer section */}
            <footer className={styles.footer}>
            </footer>
          </div>
        </>
    );
    }

    export default function termsOfUse() {
        return(
            <div className="terms-of-use">
                <h1>회원가입 정책</h1>
                <p>제 1조 (시스템관리) CRM은 팀Header(이하 "시스템관리자"라 한다)가 총괄 관리한다. <br/>
    
                      제 2 조 (회원관리) <br/>
    
                      ① CRM의 원활한 운영과 관리를 위하여 시스템관리자는 고객과 샵 관리자(이하 “회원”이라 한다)의 인적사항 정보는 시스템관리자가 관리한다. <br/>
                      ② 신규·탈퇴 회원의 발생이 있을 때에 시스템관리자는 신속히 그 사항을 변경하여 CRM 고객 정보에 반영될 수 있도록 한다. <br/>
                      ③ CRM 내 매장 및 예약 정보에 관한 등록 및 삭제는 회원의 가입 및 삭제로 자동 등록 및 삭제한다. <br/>
                      ④ CRM 회원 범위는 소규모 이미용 업계 대표 혹은 이러한 업장을 이용하는 사람으로 한다.<br/>
                      ⑤ ‘관리자’란 본 프로그램에 등록된 매장의 대표로, 관리 권한을 위임받은 사람을 말한다.<br/>
                      ⑥ ‘회원’은 서비스를 제공받는 모든 매장 이용객을 말한다.<br/>
                      ⑦ 관리자, 즉 각 업장의 사장은 자기 매장의 서비스를 이용하려는 회원의 정보를 수집할 수 있다.
                </p>
            </div>
            //위 약관은 '업무분석'의 '회원가입 정책'을 따랐습니다.
            //https://www.notion.so/ohgiraffers/218649136c1181e28cdafa31d2f5a7f1?source=copy_link
        )
    }

    "use client";
    import React, { useState } from 'react';
    import Link from 'next/link';
    
    export default function Verification() {
    const [formData, setFormData] = useState({
    userName: '',
    userPhone: '',
    });
    
            // Handle input changes
            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prevData => ({
                    ...prevData,
                    [name]: value,
                }));
            };
        
            // Handle form submission
            const handleSubmit = async (e) => {
                e.preventDefault(); // Prevent default browser form submission
        
                // 백엔드로 넘어가는 데이터 확인을 위한 코드
                console.log('Form submitted with data:', formData);
        
                try {
                    const response = await fetch('/auth/verification-code', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(formData),
                    });
        
                    if (response.ok) {
                        // Handle successful signup (e.g., redirect, show success message)
                        console.log('Verify successful');
                        alert('회원가입에 성공하였습니다!');
                        // 성공 시 로그인 페이지로 전환
                        window.location.href = '/auth/session';
                    } else {
                        // Handle errors (e.g., show error message)
                        const errorData = await response.json();
                        console.error('Verify failed:', errorData);
                        alert(`회원가입 실패: ${errorData.message || '알 수 없는 오류'}`);
                    }
                } catch (error) {
                    console.error('Error during verify phone:', error);
                    alert('회원가입 절차 중 오류가 발생했습니다. 다시 시도해주세요.');
                }
            };
        return (
            <div className="signup-container"> {/* Added a container for overall styling */}
                <h1>전화번호 인증</h1>
                <div className="content-card">
                    <form onSubmit={handleSubmit}> {/* Use onSubmit for React forms */}
                        <div className="form-group">
                            <label htmlFor="userName">이름:</label>
                            <input
                                type="text"
                                id="userName"
                                name="userName"
                                value={formData.userName}
                                onChange={handleChange}
                                required
                            />
                        </div>
    
                        <div className="form-group">
                            <label htmlFor="userPhone">전화번호:</label>
                            <input
                                type="tel"
                                id="userPhone"
                                name="userPhone"
                                value={formData.userPhone}
                                onChange={handleChange}
                                placeholder="예: 010-1234-5678"
                                pattern="[0-9]{3}-?[0-9]{4}-?[0-9]{4}"
                                required
                            />
                        </div>
    
                        <button type="submit">
                            <Link href="/auth/verification-code/validate">인증번호 발송</Link>
                        </button>
                    </form>
                </div>
            </div>
        );
    }

    "use client";
    import React, { useState } from 'react';
    
    export default function validateOX() {
    // State to manage form input values
    const [formData, setFormData] = useState({
    userName: '',
    userPhone: '',
    });
    
        // Handle input changes
        const handleChange = (e) => {
            const { name, value } = e.target;
            setFormData(prevData => ({
                ...prevData,
                [name]: value,
            }));
        };
    
        // Handle form submission
        const handleSubmit = async (e) => {
            e.preventDefault(); // Prevent default browser form submission
    
            // 백엔드로 넘어가는 데이터 확인을 위한 코드
            console.log('Form submitted with data:', formData);
    
            try {
                const response = await fetch('/auth/verification-code/validate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(formData),
                });
    
                if (response.ok) {
                    // Handle successful signup (e.g., redirect, show success message)
                    console.log('Verify successful');
                    alert('전화번호 인증에 성공하였습니다!');
                    // 성공 시 회원가입 페이지로 전환
                    window.location.href = '/auth/verification-code';
                } else {
                    // Handle errors (e.g., show error message)
                    const errorData = await response.json();
                    console.error('Verify failed:', errorData);
                    alert(`전화번호 인증 실패: ${errorData.message || '알 수 없는 오류'}`);
                }
            } catch (error) {
                console.error('Error during verify phone:', error);
                alert('전화번호 인증 절차 중 오류가 발생했습니다. 다시 시도해주세요.');
            }
        };
    
        return (
            <div className="signup-container">
                <h1>인증번호 확인</h1>
                <div className="content-card">
                    <form onSubmit={handleSubmit}>
                    <div className="form-group">
                    <label htmlFor="verifyCode">인증번호:</label>
                    <input
                    type="text"
                    id="verifyCode"
                    name="verifyCode"
                    value={formData.verifyCode}
                    onChange={handleChange}
                    required
                    />
                    </div>
                    <button type="submit">인증번호 확인</button>
                    </form>
                </div>
            </div>
        );
    }

## 13. [FRONT_END] Visual Studio Code administrator change
이전에 이 pc 이용했던 지명님 pebble0201 아이디로 자격증명이 되어있었던지

내 계정으로 로그인했는데도 터미널을 통한 push가 안 됐다.

인터넷에 검색해보니 컴퓨터 내에서 '자격 증명 관리자'를 검색한 후
![img.png](img.png)

윈도우 자격 증명 클릭,
![img_1.png](img_1.png)

그 하위 일반 자격 증명 목록 중에 git으로 시작하는 자격을 지우라고 했다.
![img_2.png](img_2.png)

지금은 지워서 못 보지만
git 관련 자격으로
사용자 이름: pebble0201로 
암호: ********
편집 제거
있었어서 '제거' 눌러 제거 완료.

그리고 비쥬얼 스튜디어 코드로 다시 들어가서
토큰을 통해 github 재로그인 완료.
