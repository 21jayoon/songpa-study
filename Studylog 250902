강한 결합과 느슨한 결합
Tight coupling and the Loose Coupling

# https://velog.io/@cabbage/%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9Tight-Coupling%EA%B3%BC-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9Loose-Coupling

강한 결합은 서로 다른 클래스들이 크게 의존하는 경우를 말한다.
예시 코드) example code
```JavaScript
export class ProductController {
  buyProduct = (req, res) => {
    const cashService = new CashServic();
    const hasMoney = cashService.checkValue();

    const productService = new ProductService();
    const isSoldout = productService.checkSoldout();
  //......
  ]
};

refundProduct = (req, rest) => {
  const productService = new ProductService();
  const isSoldout = ProductService.checkSoldout();

  if(isSoldout) {
    res.send("상품 환불 완료");
  }
}
}

ProductController 클래스에 선언한 메서드 내에서 
CashSevice와 ProductService의 객체를 직접 생성해
메서드를 호출하는 형태의 코드

ProductController클래스가 CashService, ProductService "클래스를 직접 사용"해
생성한 객체에 의존하고 있는 "강한 결합" 상태이다.

* 강한 결합의 단점
1. 유지 보수 어려움 -> 컨트롤러와 의존 관계에 있는 서비스 객체를 변경해야할 때, 
컨트롤러가 서비스 객체를 사용하고 있는 코드 모두를 수정해야함.
만약 의존 관계에 잇는 서비스 객체를 전부 수정하지 않는다면
비즈니스 로직에 문제발생 가능.

2. 서비스 객체가 필요할 때마다 서비스 객체를 생성해서 사용하므로
메모리 효율성 안 좋음 -> 서비스 객체의 로직이 필요한 경우 서비스 객체를 생성 후 사용하는데,
객체를 중복 생성하면 메모리 효율 사용 불가


느슨한 결합 Loose Coupling
강한 결합의 반대개념. 객체들이 느슨한 상태로 결합되어있다.
어떤 클래스에서 다른 클래스를 직접 사용하는 클래스 의존성을 줄인 결합 상태.
예시 코드)
```javascript
import express from "express";
import { ProductController } from "./mvc/controllers/product.controller.js";
import { CashService } from "./mvc/controllers/services/cash.service.js";

const app = express();
const cashService = new CashService();
const productController = new ProductController(cashService); // ProductController 객체 생성, cashService 객체를 생성자의 인자로 전달
app.post("/products/buy", productController.buyProduct);

CashService 객체를 index.js라는 파일1에서 생성하고, ProductController 객체를 생성할 때
생성자의 인자로 CashService 객체를 전달한다.


import { ProductService } from './services/product.service.js'

export class ProductController {
  constructor(cashService) {
    this.cashService = cashService;
  }

  buyProduct = (req, res) => {
    // const cashService = new CashService();
    const hasMoney = this.cashService.checkValue();

    const productService = new ProductService()
    const isSoldout = productService.checkSoldout();

    if (hasMoney && !isSoldout) {
      res.send("상품을 구매합니다.");
    }
  };

  refundProduct = (req, res) => {
    const productService = new ProductService()
    const isSoldout = productService.checkSoldout();

    if (isSoldout) {
      res.send("상품을 환불합니다.");
    }
  };
}

이후 constructor를 사용해 CashService 객체를 전달받는다.
ProductController와 ProductService는 아직 강한 결합 상태이다. (ProductService 객체를 직접 생성해서 사용하고 있기 때문)

ProductController 클래스는 CashService의 객체를 직접 생성 않고
ProductController외부에서 객체 생성 후 constructor(생성자)를 통해 안으로 전달하는 형태다.

Constructor Injection (생성자 주입) 방식을 통한
Dependency Injection(의존성 주입)으로
두 클래스를 느슨한 결합 상태로 만든 것.


- 강한 결합은 클래스들이 크게 의존해 강하게 결합된 상태. 관련 코드를 전체 수정해야하므로 유지보수가 어렵다.
- 느슨한 결합은 어떤 클래스에서 다른 클래스를 직접 사용하는 클래스 의존성을 줄인 결합 상태
- DI(Dependency Injection, 의존성 주입)를 통해 강한 결합을 느슨한 결함으로 바꿀 수 있다. DI에는 생성자 주입(Constructor Injection), 세터 주입(Setter Injection), 필드 주입(Field Injection) 3가지 방식이 있다.
