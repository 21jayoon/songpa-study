/** Asked to lecturer:
* 추상화: 드러나는 기능(인터페이스)이 있을 때 ‘이건 넌 모르고 있어도 돼’라고 하는 것. 인터페이스만 보이게, 내부 기능은 복잡해도 괜찮은 것.
* 캡슐화: 겉으로 드러낼 것과 숨기는(숨길) 것을 구별/구분하는 것.
* 
* Abstraction : When the feature(interface) exposed,noticing 'You don't have to know specific things about this'.
* Showing only interface, the internal(inner) feature is fine to be get complexity.
* Encapsulation : Distinguishing what to expose and what to conceal.
*
* https://www.geeksforgeeks.org/java/difference-between-abstraction-and-encapsulation-in-java-with-examples/
*/

//Encapsulation in Javascript
// Different with Java, I have to put # infront of the argument.
//Example
class Animal {
  #name; // Private property(프라이빗 속성)
  weight; // public property

  constructor(name, weight){
    this.name = name;
    this.#weight = weight;
  }

  // getter: class 외부에서 a.name처럼 접근 가능
  get name() {
    return this.name;
  }

  //setter: class 외부에서 a.name = "값"처럼 접근 가능
  set name(newName) {
    /** Setter에서는
    *   if (typeof newName != 'string') {
    *    throw new Error('Name should be String');
    *   } 와 같이 인자값 조건을 지정해줄 수도 있음
    */
    this.name = newName;
  }
}

// How to use
const a = new Animal('Mammal', 10);
a.#name();
a.weight();


//Inheritance in JS -> using 'extends'
clasee Animal {
  constructor(name) {
    this.#name = name;
  }
  speak() {
    console.log(`${this.#name} is speaking sth`);
  }
}
class Dog extends Animal{
// class Dog is extending(inheritants) class Animal
// class Dog is the sub class(child class) of Animal
// Animal is the super class(parent class) of class Dog
  bark(){
    //bark is a function in JS class
    console.log(`${this.getName()} is barking! woof!`);
  }
}

const d = new Dog('puppy');
d.speak(); //puppy is speaking sth
d.bark(); //puppy is barking! woof!

// JS cannot inheritant multi super class
//JS는 여러 개의 상속을 받을 수 없다!! (오직 하나의 부모 클래스만 상속가능)


// Understanding encapsulation and abstraction with example code
class Book{
  #royalties;
  // 인세 금액은 대외비, 따라서 private field 사용. 이를 통해 캡슐화 적용이 되었다고 할 수 있는가?

  constructor(title, author, years){
    this.title = title;
    this.author = `${author}`;
    this.years = years;
  }

  printInfo(title, author){
    console.log(`제목: ${title}, 저자: ${author}`);
  }

  #royalties_calculate(years){
    this.#royalties = years * 1234560 - 10000 + 50 / 2 * 3;
    return this.#royalties;
  }

  royalties_secret (author){
    // 이 메소드(?)에서 추상화와 캡슐화가 둘 다 적용되었다고 할 수 있을까요?
    this.#royalties_calculate(this.years);
    // 인세 금액을 드러내지 않는 것 = 캡슐화 적용
    // 복잡한 인세 구하기 공식을 rotalties_secret에서 굳이 알 필요가 없게 하는 것 = 추상화 적용
    console.log(`${author}` + "작가님 인세는 " + this.#royalties + "원입니다.");
  }
}

// 위와 같은 Book 클래스 안에 있는 여러 가지 메소드(메소드가 맞을까요?)를
// 회계부서 동료가 사용한다고 가정할 때, '추상화가 적용되었다'고 할 수 있을까요?
// (회계부서는 Book 클래스 내부의 구체적인 로직(?)까진 알지 못함)

const result = new Book("Harry Potter", "J.K. Rowling", 5);
result.royalties_secret("J.K. Rowling");
// J.K. Rowling작가님 인세는 6162875원입니다.


// async  비동기
// 비동기는 자바스크립트의 핵심 특징이다.
function sayHi() {
  console.log('Hi');
}

setTimeout(sayHi, 2000); // 전달된 sayHi는 2초(2000ms)가 지난 후 실행할 '콜백 함수'
//setTimeout의 첫 번째 인자로, sayHi를 콜백함수로 넣음
