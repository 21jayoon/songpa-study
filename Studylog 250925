/** Asked to lecturer:
* 추상화: 드러나는 기능(인터페이스)이 있을 때 ‘이건 넌 모르고 있어도 돼’라고 하는 것. 인터페이스만 보이게, 내부 기능은 복잡해도 괜찮은 것.
* 캡슐화: 겉으로 드러낼 것과 숨기는(숨길) 것을 구별/구분하는 것.
* 
* Abstraction : When the feature(interface) exposed,noticing 'You don't have to know specific things about this'.
* Showing only interface, the internal(inner) feature is fine to be get complexity.
* Encapsulation : Distinguishing what to expose and what to conceal.
*
* https://www.geeksforgeeks.org/java/difference-between-abstraction-and-encapsulation-in-java-with-examples/
*/

//Encapsulation in Javascript
// Different with Java, I have to put # infront of the argument.
//Example
class Animal {
  #name; // Private property(프라이빗 속성)
  weight; // public property

  constructor(name, weight){
    this.name = name;
    this.#weight = weight;
  }

  // getter: class 외부에서 a.name처럼 접근 가능
  get name() {
    return this.name;
  }

  //setter: class 외부에서 a.name = "값"처럼 접근 가능
  set name(newName) {
    /** Setter에서는
    *   if (typeof newName != 'string') {
    *    throw new Error('Name should be String');
    *   } 와 같이 인자값 조건을 지정해줄 수도 있음
    */
    this.name = newName;
  }
}

// How to use
const a = new Animal('Mammal', 10);
a.#name();
a.weight();


//Inheritance in JS -> using 'extends'
clasee Animal {
  constructor(name) {
    this.#name = name;
  }
  speak() {
    console.log(`${this.#name} is speaking sth`);
  }
}
class Dog extends Animal{
// class Dog is extending(inheritants) class Animal
// class Dog is the sub class(child class) of Animal
// Animal is the super class(parent class) of class Dog
  bark(){
    //bark is a function in JS class
    console.log(`${this.getName()} is barking! woof!`);
  }
}

const d = new Dog('puppy');
d.speak(); //puppy is speaking sth
d.bark(); //puppy is barking! woof!

// JS cannot inheritant multi super class
//JS는 여러 개의 상속을 받을 수 없다!! (오직 하나의 부모 클래스만 상속가능)


// Understanding encapsulation and abstraction with example code
class Book{
  #royalties;
  // 인세 금액은 대외비, 따라서 private field 사용. 이를 통해 캡슐화 적용이 되었다고 할 수 있는가?

  constructor(title, author, years){
    this.title = title;
    this.author = `${author}`;
    this.years = years;
  }

  printInfo(title, author){
    console.log(`제목: ${title}, 저자: ${author}`);
  }

  #royalties_calculate(years){
    this.#royalties = years * 1234560 - 10000 + 50 / 2 * 3;
    return this.#royalties;
  }

  royalties_secret (author){
    // 이 메소드(?)에서 추상화와 캡슐화가 둘 다 적용되었다고 할 수 있을까요?
    this.#royalties_calculate(this.years);
    // 인세 금액을 드러내지 않는 것 = 캡슐화 적용
    // 복잡한 인세 구하기 공식을 rotalties_secret에서 굳이 알 필요가 없게 하는 것 = 추상화 적용
    console.log(`${author}` + "작가님 인세는 " + this.#royalties + "원입니다.");
  }
}

// 위와 같은 Book 클래스 안에 있는 여러 가지 메소드(메소드가 맞을까요?)를
// 회계부서 동료가 사용한다고 가정할 때, '추상화가 적용되었다'고 할 수 있을까요?
// (회계부서는 Book 클래스 내부의 구체적인 로직(?)까진 알지 못함)

const result = new Book("Harry Potter", "J.K. Rowling", 5);
result.royalties_secret("J.K. Rowling");
// J.K. Rowling작가님 인세는 6162875원입니다.


// async  비동기
// 비동기는 자바스크립트의 핵심 특징이다.
function sayHi() {
  console.log('Hi');
}

setTimeout(sayHi, 2000); // 전달된 sayHi는 2초(2000ms)가 지난 후 실행할 '콜백 함수'
//setTimeout의 첫 번째 인자로, sayHi를 콜백함수로 넣음


// Q: 개발 시 동기와 비동기를 선택할 수 있나요? (다른 사람 질문)
// A: yes. for example, 파일 로드 같은 경우에는 ssd가 작동하는 긴 시간이 소요되는 활동인데,
// 이 때 동기와 비동기를 선택해서 자원의 효율적인 활용을 유도(?)할 수 있음.

// 내 질문:
// Q: 비동기가 컴퓨터 자원활용면에서 동기방식보다 더 효율적이라는 것이 단번에 이해가 되지 않음.
// cs 면에서의 '효율적'이라는 것의 기준이 "시스템 자원 유휴상태를 최대한 줄이는 것", 
// "애플리케이션이 '요청을 보냈을 때 최대한 빠르게 요청을 처리'하는 것"이기 때문에 비동기 방식이 더 효율적이라고 하는 건가요?
// 왠지 동기 방식이 먼저 온 것부터 하나씩 차근히 처리하니까 '효율적'이라고 느껴지는데, 시스템 자원 기준의 '효율성' 기준이 궁금함.
// A: 시스템 자원 기준의 '효율성'은 시간적인 측면.
// 중간에 오래 걸리는 작업 때문에 
// 그 다음 작업을 처리 못하고 기다려야하는 건 (시간을 흘려보내야하는 게) 비효율적이다고 할 수 있음.
// 시스템 자원이 더 일을 할 수 있음에도 계속 대기만 하고 있다면 그것이 시스템 자원의 낭비(+시간 낭비)라고 할 수 있음
// A2: 정확한 설명일지는 모르겠지만 요리할 때 생각해보시면 좋을 것 같습니다.
// 고기를 해동시키기 위해 전자레인지에서 해동을 돌리면서 다른 작업을 하지 않고
// 전자레인지를 쳐다보고 있는 것은 비효율적이기에
// 전자레인지가 끝날 때 까지 재료를 처리한다던가 등의 다른 일을 처리하면
// 효율적으로 요리를 한다고 생각 해주시면 좋을 것 같습니다. (인학님 설명)
// Conclusion:
// 애플리케이션 요청 시 처리하는 데에 드는 "시간 소요 정도"와 "시스템 자원 유휴상태"를 기준으로
// 시스템 자원의 효율성을 생각하면 된다. 
// (실행이 빠르게 되고(시간이 짧게 걸리고) 시스템 자원이 비어있는 시간이 길지 않은 것이 '효율적')

// Promise
/* (다른 사람 질문) 비동기 함수를 실행후의 값을 프로미스에 할당 된다고 생각해도 될까요 -> Sort of. Maybe.
* 그렇다면 비동기 작업이 안료된 이후 값이 어떠한 객체에 담기는데 
* 그 객체의 이름을 그냥 promise라고 부르자고 약속을 했다 라고 생각해면 될까요 -> Yes */
