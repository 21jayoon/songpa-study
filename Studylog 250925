/** Asked to lecturer:
* 추상화: 드러나는 기능(인터페이스)이 있을 때 ‘이건 넌 모르고 있어도 돼’라고 하는 것. 인터페이스만 보이게, 내부 기능은 복잡해도 괜찮은 것.
* 캡슐화: 겉으로 드러낼 것과 숨기는(숨길) 것을 구별/구분하는 것.
* 
* Abstraction : When the feature(interface) exposed,noticing 'You don't have to know specific things about this'.
* Showing only interface, the internal(inner) feature is fine to be get complexity.
* Encapsulation : Distinguishing what to expose and what to conceal.
*
* https://www.geeksforgeeks.org/java/difference-between-abstraction-and-encapsulation-in-java-with-examples/
*/

//Encapsulation in Javascript
// Different with Java, I have to put # infront of the argument.
//Example
class Animal {
  #name; // Private property(프라이빗 속성)
  weight; // public property

  constructor(name, weight){
    this.name = name;
    this.#weight = weight;
  }

  // getter: class 외부에서 a.name처럼 접근 가능
  get name() {
    return this.name;
  }

  //setter: class 외부에서 a.name = "값"처럼 접근 가능
  set name(newName) {
    /** Setter에서는
    *   if (typeof newName != 'string') {
    *    throw new Error('Name should be String');
    *   } 와 같이 인자값 조건을 지정해줄 수도 있음
    */
    this.name = newName;
  }
}

// How to use
const a = new Animal('Mammal', 10);
a.#name();
a.weight();


//Inheritance in JS -> using 'extends'
clasee Animal {
  constructor(name) {
    this.#name = name;
  }
  speak() {
    console.log(`${this.#name} is speaking sth`);
  }
}
class Dog extends Animal{
// class Dog is extending(inheritants) class Animal
// class Dog is the sub class(child class) of Animal
// Animal is the super class(parent class) of class Dog
  bark(){
    //bark is a function in JS class
    console.log(`${this.getName()} is barking! woof!`);
  }
}

const d = new Dog('puppy');
d.speak(); //puppy is speaking sth
d.bark(); //puppy is barking! woof!

// JS cannot inheritant multi super class
//JS는 여러 개의 상속을 받을 수 없다!! (오직 하나의 부모 클래스만 상속가능)
