# Reference: https://softwaresaramdle.tistory.com/73
https://project-555.github.io/docs/plog-back/email_verification/

1. 이메일 인증이 꼭 필요할까에 대한 고민
초기에는 다른 사이트에서도 보통 회원가입 시 전화번호를 통한 인증을 거쳐
가입을 가능케 하기 때문에 생각없이 
'그럼 우리 프로젝트도 핸드폰 인증을 통해 본인인증을 받아야겠다.'고 생각함.
그러나 핸드폰 번호로 본인인증을 거치기 위해서는 smsAPI가 필요한데,
몇 년 전과 달리 이젠 사업자 번호가 있어야 해당 API 서비스 신청이 가능한 것을 알게 됨.

이에 이메일을 통한 본인인증 구현을 고려해봄과 동시에
진지하게 본인인증 구현의 필요성에 대해 고민해봄.

일단 본인인증 구현의 필요성에 대해,
우리 프로젝트는 엄밀히 말하자면 공부를 위한 프로젝트이기 때문에
실제 본인인증을 통한 중복 검사나 타인 정보 이용 방지 등이 
꼭 필요하다고 생각치 않았음.

그러나 저번 발표 때 어느 대표님의 피드백을 통해
실제 프로그램 판매 등을 가정하고 개발을 하는 것이 
좀 더 실무에 가까운 사고 방식이라는 깨달음을 얻었고,
또 redis가 무엇인지 공부해보기 위해
redis를 이용해 이메일을 저장 후 본인 인증 과정을 구현해보기로 함.

# "/profile" 관련 기능 보강
https://pine-fibula-aee.notion.site/FIX-profile-update2-25bfc892a16f807295f7dbad012bf241?pvs=74

** 예외처리
DB와 동일한 값을 입력해도 Http response 200이 떠서 "정상적으로 정보가 수정되었습니다."라는 alert가 뜸.
userSerivce에 연결된 APIResponse에 관한 부분에 Httpstatus 관련 자료가 있는 것을 발견.
생각해보니 1차 개발 때 이전에 회원가입에서의 다른 부분일 때는 Httpstatus.CONFLICT 같은 게 제대로 넘어와서 콘솔에 보여졌는데 
왜 이번 메소드에서는 안 되는 건지 의문.
그리고 회원가입 메소드를 살펴봄.
/* 1. 중복 유효성 검사 */
        // 중복확인 1 : userId
        if (userRepository.existsByUserId(userDTO.getUserId())) {
            log.info("[AuthService] 아이디 중복");
            throw new DuplicatedUserIdException(ApiResponse.DUPLICATE_ID.getMessage());
        }
        // 중복확인 2 : userPhone
        if (userRepository.existsByUserPhone(userDTO.getUserPhone())) {
            log.info("[AuthService] 전화번호 중복");
            throw new DuplicatedPhoneException(ApiResponse.DUPLICATE_PHONE.getMessage());
        }
중복 유효성 검사 시 exception을 같이 던지고 있었음.

단순 중복검사에서 Http response까지 고려한 중복 유효성 검사로의 코드 수정 필요성을 느낌.
@Transactional
    public String modifyUser(UserDTO userDTO){
        //String을 UserDTO로 자료형 바꿔야하나? 0826 14:43
        // 1. 기존 유저 엔티티 조회
        User user = userRepository.findById(userDTO.getUserCode())
                .orElseThrow(() -> new IllegalArgumentException("해당 유저가 존재하지 않습니다."));

        // 2. 이전에 사용한 값과 동일한지 확인
        if (userDTO.getUserName() != null && user.getUserName().equals(userDTO.getUserName())) {
            log.info("[UserService] 이전과 같은 이름을 입력함");
            throw new SameNameException(userDTO.getUserName() + SAME_NAME.getMessage());
        }

        if (userDTO.getUserPhone() != null && user.getUserPhone().equals(userDTO.getUserPhone())) {
            log.info("[UserService] 이전과 같은 전화번호를 입력함");
            throw new SamePhoneException(userDTO.getUserPhone() + SAME_PHONE.getMessage());
        }

        if (userDTO.getUserPwd() != null && passwordEncoder.matches(userDTO.getUserPwd(), user.getUserPwd())) {
            log.info("[UserService] 이전과 같은 비밀번호를 입력함");
            throw new SamePwdException(userDTO.getUserPwd() + SAME_PASSWORD.getMessage());
        }

        // 3. DB 전체와 비교, 전화번호 중복 확인 (자기 자신 제외)
        if (userRepository.existsByUserPhoneAndUserCodeNot(userDTO.getUserPhone(), userDTO.getUserCode())) {
            return DUPLICATE_PHONE.getMessage();
        }

        // 4. 도메인 메서드를 통한 정보 수정
        if (isNotEmpty(userDTO.getUserPwd())) {
            String encodedPwd = passwordEncoder.encode(userDTO.getUserPwd());
            user.modifyUserPassword(encodedPwd);
        }
        if (isNotEmpty(userDTO.getUserPhone())) user.modifyUserPhone(userDTO.getUserPhone());
        if (isNotEmpty(userDTO.getUserName())) user.modifyUserName(userDTO.getUserName());

        userRepository.save(user); //Put .save explicitly

        return SUCCESS_MODIFY_USER.getMessage();
    }
모든 중복 유효성 검사에 exception 넣어줌.    
