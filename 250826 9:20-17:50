# Reference: https://softwaresaramdle.tistory.com/73
https://project-555.github.io/docs/plog-back/email_verification/

1. 이메일 인증이 꼭 필요할까에 대한 고민
초기에는 다른 사이트에서도 보통 회원가입 시 전화번호를 통한 인증을 거쳐
가입을 가능케 하기 때문에 생각없이 
'그럼 우리 프로젝트도 핸드폰 인증을 통해 본인인증을 받아야겠다.'고 생각함.
그러나 핸드폰 번호로 본인인증을 거치기 위해서는 smsAPI가 필요한데,
몇 년 전과 달리 이젠 사업자 번호가 있어야 해당 API 서비스 신청이 가능한 것을 알게 됨.

이에 이메일을 통한 본인인증 구현을 고려해봄과 동시에
진지하게 본인인증 구현의 필요성에 대해 고민해봄.

일단 본인인증 구현의 필요성에 대해,
우리 프로젝트는 엄밀히 말하자면 공부를 위한 프로젝트이기 때문에
실제 본인인증을 통한 중복 검사나 타인 정보 이용 방지 등이 
꼭 필요하다고 생각치 않았음.

그러나 저번 발표 때 어느 대표님의 피드백을 통해
실제 프로그램 판매 등을 가정하고 개발을 하는 것이 
좀 더 실무에 가까운 사고 방식이라는 깨달음을 얻었고,
또 redis가 무엇인지 공부해보기 위해
redis를 이용해 이메일을 저장 후 본인 인증 과정을 구현해보기로 함.

# "/profile" 관련 기능 보강
https://pine-fibula-aee.notion.site/FIX-profile-update2-25bfc892a16f807295f7dbad012bf241?pvs=74

** 예외처리
DB와 동일한 값을 입력해도 Http response 200이 떠서 "정상적으로 정보가 수정되었습니다."라는 alert가 뜸.
userSerivce에 연결된 APIResponse에 관한 부분에 Httpstatus 관련 자료가 있는 것을 발견.
생각해보니 1차 개발 때 이전에 회원가입에서의 다른 부분일 때는 Httpstatus.CONFLICT 같은 게 제대로 넘어와서 콘솔에 보여졌는데 
왜 이번 메소드에서는 안 되는 건지 의문.
그리고 회원가입 메소드를 살펴봄.
/* 1. 중복 유효성 검사 */
        // 중복확인 1 : userId
        if (userRepository.existsByUserId(userDTO.getUserId())) {
            log.info("[AuthService] 아이디 중복");
            throw new DuplicatedUserIdException(ApiResponse.DUPLICATE_ID.getMessage());
        }
        // 중복확인 2 : userPhone
        if (userRepository.existsByUserPhone(userDTO.getUserPhone())) {
            log.info("[AuthService] 전화번호 중복");
            throw new DuplicatedPhoneException(ApiResponse.DUPLICATE_PHONE.getMessage());
        }
중복 유효성 검사 시 exception을 같이 던지고 있었음.

단순 중복검사에서 Http response까지 고려한 중복 유효성 검사로의 코드 수정 필요성을 느낌.
@Transactional
    public String modifyUser(UserDTO userDTO){
        //String을 UserDTO로 자료형 바꿔야하나? 0826 14:43
        // 1. 기존 유저 엔티티 조회
        User user = userRepository.findById(userDTO.getUserCode())
                .orElseThrow(() -> new IllegalArgumentException("해당 유저가 존재하지 않습니다."));

        // 2. 이전에 사용한 값과 동일한지 확인
        if (userDTO.getUserName() != null && user.getUserName().equals(userDTO.getUserName())) {
            log.info("[UserService] 이전과 같은 이름을 입력함");
            throw new SameNameException(userDTO.getUserName() + SAME_NAME.getMessage());
        }

        if (userDTO.getUserPhone() != null && user.getUserPhone().equals(userDTO.getUserPhone())) {
            log.info("[UserService] 이전과 같은 전화번호를 입력함");
            throw new SamePhoneException(userDTO.getUserPhone() + SAME_PHONE.getMessage());
        }

        if (userDTO.getUserPwd() != null && passwordEncoder.matches(userDTO.getUserPwd(), user.getUserPwd())) {
            log.info("[UserService] 이전과 같은 비밀번호를 입력함");
            throw new SamePwdException(userDTO.getUserPwd() + SAME_PASSWORD.getMessage());
        }

        // 3. DB 전체와 비교, 전화번호 중복 확인 (자기 자신 제외)
        if (userRepository.existsByUserPhoneAndUserCodeNot(userDTO.getUserPhone(), userDTO.getUserCode())) {
            throw new DuplicatedPhoneException(ApiResponse.DUPLICATE_PHONE.getMessage());
        }

        // 4. 도메인 메서드를 통한 정보 수정
        if (isNotEmpty(userDTO.getUserPwd())) {
            String encodedPwd = passwordEncoder.encode(userDTO.getUserPwd());
            user.modifyUserPassword(encodedPwd);
        }
        if (isNotEmpty(userDTO.getUserPhone())) user.modifyUserPhone(userDTO.getUserPhone());
        if (isNotEmpty(userDTO.getUserName())) user.modifyUserName(userDTO.getUserName());

        userRepository.save(user); //Put .save explicitly

        return SUCCESS_MODIFY_USER.getMessage();
    }
모든 중복 유효성 검사에 exception 넣어줌.    
ApiResponse에 400번대 HttpStatus를 넣어줬는데,
localhost에선 500번 서버내부 오류가 발생하는 것을 확인.

-> GlobalExceptionHandlerForApiResponse에서 
추가적으로 exceptionHandler 메소드 설정을 해줘야한다는 것을 확인.
// SameNameException 처리 (400 BAD_REQUEST)
    @ExceptionHandler(SameNameException.class)
    public ResponseEntity<ErrorResponse> handleSameNameException (SameNameException ex, WebRequest request) {
        log.warn("SameNameException 발생: {}", ex.getMessage());
        // ErrorResponse의 of() 팩토리 메소드 사용
        ErrorResponse errorResponse = ErrorResponse.of(
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                ex.getMessage(),
                request.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // SamePhoneException 처리 (400 BAD_REQUEST)
    @ExceptionHandler(SamePhoneException.class)
    public ResponseEntity<ErrorResponse> handleSamePhoneException (SamePhoneException ex, WebRequest request){
        log.warn("SamePhoneException 발생 : {}", ex.getMessage());
        ErrorResponse response = ErrorResponse.of(
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                ex.getMessage(),
                request.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    // SamePwdException 처리(400 BAD_REQUEST)
    @ExceptionHandler(SamePwdException.class)
    public ResponseEntity<ErrorResponse> handleSamePwdException (SamePwdException ex, WebRequest request){
        //예외 발생 시 서버 로그를 남기는 코드
        log.warn("SamePwdException 발생 : {}", ex.getMessage());
        // ex.getMessage() : 발생한 예외(ex) 객체에 담긴 예외 메시지를 가져옵
        ErrorResponse response = ErrorResponse.of(
                // HttpStatus.BAD_REQUEST.value(), HttpStatus.BAD_REQUEST.getReasonPhrase():
                // HTTP 상태 코드 400(Bad Request)의 숫자 값(400)과
                // HTTP 상태 코드 400에 해당하는 문구인 "Bad Request"를 가져온다.
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                ex.getMessage(),
                //request.getDescription(false).replace("uri=", ""): WebRequest 객체에서 요청 URI와 같은 요청 정보를 가져옵니다.
                //        getDescription(false)는 요청 URI를 uri= 형태로 반환하기 때문에
                //        replace("uri=", "")를 통해 uri= 부분을 제거하고 순수한 URI만 남긴다.
                request.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }
-> 기존에 작성했던 코드를 일단 복사하고 붙여넣는 수준으로 작성하긴 했는데
상세한 이해가 필요할 것 같아서 Gemini에게 위 코드를 줄마다 상세하게 설명해달라고 함.

@ExceptionHandler(SamePhoneException.class)
이 어노테이션은 Spring Framework에서 발생하는 특정 예외를 처리하는 메서드를 지정합니다.
@ExceptionHandler: 이 어노테이션이 붙은 메서드는 컨트롤러나 전역 예외 처리 클래스(GlobalExceptionHandler)에서 특정 예외가 발생했을 때 자동으로 실행됩니다.
(SamePhoneException.class): 괄호 안의 SamePhoneException.class는 이 메서드가 처리할 예외의 종류를 나타냅니다. 
        클래스 객체(.class)를 인자로 전달하여 어떤 예외 클래스를 핸들링할지 명시적으로 지정하는 방식입니다. 
        .class를 사용하지 않고 그냥 SamePhoneException이라고만 쓰면 자바 문법 오류가 발생합니다.

public ResponseEntity<ErrorResponse> handleSamePhoneException (SamePhoneException ex, WebRequest request){
예외를 처리하는 메서드의 선언부.
public: 이 메서드가 다른 클래스에서도 접근 가능하도록 공개(public)되었음을 의미합니다.
ResponseEntity<ErrorResponse>: 이 메서드가 반환할 데이터의 타입. 
        ResponseEntity는 HTTP 응답 본문(body)뿐만 아니라 상태 코드, 헤더 등 HTTP 응답 전체를 제어할 수 있게 해주는 Spring의 클래스이다.
        <ErrorResponse>는 응답 본문의 타입이 ErrorResponse 클래스임을 나타낸다.
handleSamePhoneException: 메서드의 이름입니다. 예외를 처리하는 역할을 명확히 알 수 있도록 지어졌습니다.
        (SamePhoneException ex, WebRequest request): 이 메서드가 받을 매개변수입니다.
SamePhoneException ex: 발생한 예외 객체 그 자체를 ex라는 변수로 받습니다. 이 객체를 통해 예외 메시지 등 상세 정보를 얻을 수 있습니다.
WebRequest request: HTTP 요청에 대한 다양한 정보를 담고 있는 객체입니다. 요청 URI와 같은 정보를 얻는 데 사용됩니다.

log.warn("SamePhoneException 발생 : {}", ex.getMessage());
이것은 예외 발생 시 서버 로그를 남기는 코드입니다.
log.warn(): 로깅 프레임워크(예: SLF4J, Logback)를 사용하여 경고(warn) 레벨의 로그를 출력합니다.
"SamePhoneException 발생 : {}": 로그에 남길 문자열 템플릿입니다. {}는 플레이스홀더(placeholder)로, 뒤에 오는 값이 이 자리에 들어갑니다.
ex.getMessage(): 발생한 예외(ex) 객체에 담긴 예외 메시지를 가져온다. 이 코드에서 message는 APIRESPONSE에 상수로 담긴 메세지를 갖고 오게 된다.
        이 메시지가 {} 자리에 들어가 로그에 기록됩니다. 
        이를 통해 서버 관리자는 어떤 예외가 발생했는지 로그를 통해 쉽게 파악할 수 있습니다.

ErrorResponse response = ErrorResponse.of(...)
이것은 클라이언트에게 보낼 에러 응답 본문(body) 객체를 생성하는 부분입니다.
ErrorResponse response =: ErrorResponse 타입의 response 객체를 생성합니다.
ErrorResponse.of(...): ErrorResponse 클래스의 정적 팩토리 메서드인 of()를 호출하여 ErrorResponse 객체를 만듭니다. 이 메서드는 여러 인자를 받아서 객체를 생성합니다.

HttpStatus.BAD_REQUEST.value(): HTTP 상태 코드 **400(Bad Request)**의 숫자 값(400)을 가져옵니다.
HttpStatus.BAD_REQUEST.getReasonPhrase(): HTTP 상태 코드 400에 해당하는 문구인 "Bad Request"를 가져옵니다.
ex.getMessage(): 위에서 설명한 대로, 예외에 담긴 상세 메시지를 가져옵니다.
request.getDescription(false).replace("uri=", ""): WebRequest 객체에서 요청 URI와 같은 요청 정보를 가져옵니다. 
        getDescription(false)는 요청 URI를 uri= 형태로 반환하며, replace("uri=", "")를 통해 uri= 부분을 제거하고 순수한 URI만 남깁니다.

return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
이것은 최종적으로 클라이언트에게 HTTP 응답을 반환하는 부분입니다.
return new ResponseEntity<>(...): ResponseEntity 객체를 새로 생성하여 반환합니다.
response: 앞서 생성한 ErrorResponse 객체를 응답 본문으로 설정합니다.
HttpStatus.BAD_REQUEST: HTTP 상태 코드를 400 Bad Request로 설정합니다. 클라이언트는 이 상태 코드를 보고 요청이 잘못되었음을 알 수 있습니다.

이 코드는 SamePhoneException이 발생했을 때, 클라이언트에게 HTTP 400 상태 코드와 함께 상세한 에러 정보를 담은 JSON 형태의 응답을 보내는 역할을 수행합니다.
