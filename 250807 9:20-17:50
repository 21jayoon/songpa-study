https://pine-fibula-aee.notion.site/Make-AI-sommelier-and-run-with-streamlit-248fc892a16f805eb649c01729b7366d

# 04_ai_sommlier_rag.py
# jupyter notebook 파일 말고 .py파일로 생성
# 환경변수 설정
from dotenv import load_dotenv
load_dotenv()
# CTRL+SHIFT+P눌러서 pythoon_env로 인터프리터 가상환경 설정

from langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser

from langchain_openai.embeddings import OpenAIEmbeddings
from langchain_pinecone import PineconeVectorStore
import os

from langchain_core.runnables import RunnableLambda

#아까 프롬프트 전달하고 했던 것을 이번에는 함수로 전달
# 1. 요리 맛 설명 함수
def describe_dish_flavor(query):
    prompt = ChatPromptTemplate.from_messages([
        ('system', '''
         Persona: You are professional gourmet who works at this field over the 10 years. You have a deep understanding of culinary techniques, flavor profiles, and ingredient pairings. You have a passion for exploring diverse cuisines and an ability to articulate the sensory experience of food. Your insights are backed by both practical experience and theoretical knowledge, making you a trusted source in the culinary field.
        
         Role: As a professional gourmet, your role is to analyze the flavors, textures, and aromas of various dishes. You provide detailed evaluations of ingredients and cooking methods, helping others understand how to create balanced and harmonious dishes. You also educate individuals on how to enhance their cooking skills and appreciate the art of gastronomy.
         
         Examples:

         When asked to analyze the flavor profile of a dish, you describe the balance between acidity, sweetness, bitterness, and umami, explaining how these elements interact to create a complex taste experience.
         If someone inquires about the best techniques for enhancing a specific ingredient, you offer practical advice, such as how to caramelize onions for depth of flavor or how to properly season meat to bring out its natural taste.
         When discussing food pairings, you suggest complementary ingredients and flavors, explaining the rationale behind each choice, such as pairing citrus with seafood to brighten the dish or using herbs to elevate the overall taste.
         '''),
         ('user', '이미지를 분석해서 요리명과 예상되는 풍미를 한 문장으로 요약해줘.')
    ])

    template = []
    if query.get("image_urls"):
        template += [{"image_url": image_url} from image_url in query["image_urls"]]
    # prompt에선 concat 연산도 지원해준다.
    prompt += HumanMessagePromptTemplate.from_template(template)
    model= ChatOpenAI(model_name='gpt-4.1', temperature=0, max_tokens=4095)
    output_parser = StrOutputParser()

    # chain 연결
    chain = prompt | model | output_parser
    return chain

PINECONE_INDEX_NAME = os.getenv('PINECONE_INDEX_NAME')
PINECONE_NAMESPACE = os.getenv('PINECONE_NAMESPACE')
PINECONE_API_KEY = os.getenv('PINECONE_API_KEY')

# 2. 와인 찾기 위한 함수 정의
def search_wines(dish_flavor):
    # 임베딩 모델 만들기
    embeddings = OpenAIEmbeddings(model='text-embedding-3-small')

    # vector db를 쓸 거예요.
    vector_db = PineconeVectorStore(  # Pinecone (vector) DB에 연결
        embedding=embeddings,
        index_name=os.getenv('PINECONE_INDEX_NAME'),
        namespace=os.getenv('PINECONE_NAMESPACE'),
        pinecone_api_key=os.getenv('PINECONE_API_KEY')
    )
    results = vector_db.similarity_search(
        query,
        k=5,
        namespace=os.getenv('PINECONE_NAMESPACE')
    )
    return {
        "dish_flavor": query,
        "wine_reviews": "\n".join([doc.page_content for doc in results])
    }

# 3. 와인 추천
# 세번째 함수, 와인 추천받을 recommend_wines 함수
def recommend_wines(query):
    prompt = ChatPromptTemplate([
        ('system', """
        Persona: You are a knowledgeable and experienced sommelier with a passion for wine and food pairings. You possess an extensive understanding of various wine regions, grape varieties, and tasting notes. Your demeanor is friendly and approachable, making wine accessible to everyone, whether they are novices or connoisseurs.

        Role: As a sommelier, your role is to provide expert recommendations for wine selections that perfectly complement a variety of cuisines. You guide individuals in exploring new wines and help them understand the intricacies of wine tasting. Your goal is to enhance their dining experience by matching the right wine with the right dish.

        Examples:

        When asked for a wine recommendation for grilled garlic butter shrimp, you suggest a Chardonnay or Albariño, explaining how the wine's acidity balances the richness of the dish.
        If someone inquires about affordable yet high-quality wines, you recommend specific options from different regions, highlighting their flavor profiles and food pairings.
        When discussing wine storage, you provide practical advice on temperature, humidity, and ideal conditions to preserve wine quality.
        """),
        # image url도 전달해야하기 때문에 ('human', ''' (설정내용) ''')같은 방식(튜플 형태) 말고 HMPT를 쓴다.
        HumanMessagePromptTemplate.from_template("""
        와인페어링을 아래 사진 속의 요리와 풍미, 와인리뷰만을 참고하여 한글로 추천해주세요.
        요리와 풍미:
        {dish_flavor}
        와인리뷰:
        {wine_reviews} 
        """)
    ])

    model = ChatOpenAI(
        model_name='gpt-4.1',
        temperature=1,
        max_tokens=4096
    )

    output_parser = StrOutputParser()

    chain = prompt | model | output_parser
    return chain

#4. 위의 세 가지 함수 체인 하나로 연결
# 03_rag.ipynb와 달리 함수로 선언 후 체언 연결
def ai_sommelier_rag(image_urls):
    r1 = RunnableLambda(describe_dish_flavor)
    r2 = RunnableLambda(search_wines)
    r3 = RunnableLambda(recommend_wines)

    chain = r1 | r2 | r3
    return chain.stream({
        "image_urls" : image_urls
    })
    # app.py에서 streamlit을 활용해 실행



    # pip install PIL 시도
    PS D:\lecture\17_langchain> pip install PIL
    Defaulting to user installation because normal site-packages is not writeable
    ERROR: Could not find a version that satisfies the requirement PIL (from versions: none)
    
    [notice] A new release of pip is available: 25.1.1 -> 25.2
    [notice] To update, run: python.exe -m pip install --upgrade pip
    ERROR: No matching distribution found for PIL
    
    # PS D:\lecture\17_langchain>  pip install pillow

    Defaulting to user installation because normal site-packages is not writeable
    Requirement already satisfied: pillow in c:\users\user\appdata\roaming\python\python313\site-packages (11.3.0)
    
    [notice] A new release of pip is available: 25.1.1 -> 25.2
    [notice] To update, run: python.exe -m pip install --upgrade pip
    PS D:\lecture\17_langchain> python.exe -m pip install --upgrade pip
    Defaulting to user installation because normal site-packages is not writeable
    Requirement already satisfied: pip in c:\python313\lib\site-packages (25.1.1)
    Collecting pip
      Downloading pip-25.2-py3-none-any.whl.metadata (4.7 kB)
    Downloading pip-25.2-py3-none-any.whl (1.8 MB)
       ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 1.8/1.8 MB 32.2 MB/s eta 0:00:00
    Installing collected packages: pip
      WARNING: The scripts pip.exe, pip3.13.exe and pip3.exe are installed in 'C:\Users\User\AppData\Roaming\Python\Python313\Scripts' which is not on PATH.
      Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
    Successfully installed pip-25.2
    
    PS D:\lecture\17_langchain> pip install pillow
    Defaulting to user installation because normal site-packages is not writeable
    Requirement already satisfied: pillow in c:\users\user\appdata\roaming\python\python313\site-packages (11.3.0)


# 실행파일 app.py
import streamlit as st
import requests as rq
from PIL import Image
# import PIL import Image <- 왜 안 되나했더니 import 구문을 2번 씀
from io import BytesIO
# To import 04_ai_sommlier_rag, edit the file name into 'ai_sommlier_rag'
# When I tried with 'import 04_ai_sommlier_rag', it didn't worked due to the file naming convention.
import ai_sommlier_rag as ai_sommelier_rag

# PIL = Python Image Library (called 'Pillow')

# 제목과 설명
st.title("AI Wine Sommelier")
st.write("When you input the image url of the food, the AI will recommend a good pairing of wine.")

# image url받을 form 생성
with st.form(key="img_form"):
    img_url = st.text_input("이미지 URL 입력: ", placeholder="예시 https://example.com/food.jpg ")
    submit_button = st.form_submit_button(label="Submit")

# 이미지 URL이 첨부(입력)되었을 때만 버튼이 나오게 조건을 건다(if문)
if submit_button:
    if img_url:
        try:
            #URL에서 이미지 로드
            response = rq.get(img_url)
            #URL 오류 처리
            response.raise_for_status()
            image = Image.open(BytesIO(response.content))
            st.image(image)

            # AI message(와인 추천 답변) 나올 공간 생성
            st.subheader("AI wine recommendation: ")
            with st.spinner("Searching for the good pairing of wine..."):
                # spinner = LLM 같이 바로 완료가 되지 않는 비동기적인 작업을 할 때
                # 사용자에게 어떤 작업이 이루어지고 있는지 보여줄 수 있는 기능
                
                # ai_rag.py에 썼던 함수들 여기서 사용
                response = ai_sommelier_rag([img_url])
                st.write_stream(response)
        except Exception as e:
            st.error(f"There's an error while loading the image: {e}")
else:
    st.warning("Please input the image URL first")



# RUN streamlit
# !!! Mind that running streamlit must worked in cmd not a powershell
(pythonstudy_env) D:\lecture\17_langchain>cd 04_ai_sommelier_rag

(pythonstudy_env) D:\lecture\17_langchain\04_ai_sommelier_rag>streamlit run app.py

  You can now view your Streamlit app in your browser.

  Local URL: http://localhost:8501
  Network URL: http://192.168.1.111:8501


# Error occurred
────────────────────────── Traceback (most recent call last) ───────────────────────────
  C:\Users\User\miniconda3\envs\pythonstudy_env\Lib\site-packages\streamlit\runtime\sc
  riptrunner\exec_code.py:128 in exec_func_with_error_handling

  C:\Users\User\miniconda3\envs\pythonstudy_env\Lib\site-packages\streamlit\runtime\sc
  riptrunner\script_runner.py:669 in code_to_exec

  D:\lecture\17_langchain\04_ai_sommelier_rag\app.py:6 in <module>

     3 import requests as rq
     4 from PIL import Image
     5 from io import BytesIO
  ❱  6 from ai_sommlier_rag import ai_sommelier_rag
     7 # Python Image Library (called 'Pillow')
     8 
     9 # 제목과 설명
────────────────────────────────────────────────────────────────────────────────────────
────────────────────────────────────────────────────────────────────────────────────────
   D:\lecture\17_langchain\04_ai_sommelier_rag\ai_sommlier_rag.py:37
          template += [{"image_url": image_urls} from image_url in query["image_urls"]
                                                 ▲
────────────────────────────────────────────────────────────────────────────────────────
SyntaxError: invalid syntax
-> FIX:
       template += [{"image_url": image_url} for image_url in query["image_urls"]]

       
# Test the program run well
# 1. Find image url from google
https://recipe1.ezmember.co.kr/cache/recipe/2016/04/18/618714c513dc25a83212b7b911cd7dfc1.jpg

# 2. Put an image url in to a url input form
# !!! ERROR
There's an error while loading the image: name 'query' is not defined

# I think this part in the ai_sommlier_rag.py was the problem
# 2. 와인 찾기 위한 함수 정의
def search_wines(dish_flavor):
    # 임베딩 모델 만들기
    embeddings = OpenAIEmbeddings(model='text-embedding-3-small')

    # vector db를 쓸 거예요.
    vector_db = PineconeVectorStore(  # Pinecone (vector) DB에 연결
        embedding=embeddings,
        index_name=os.getenv('PINECONE_INDEX_NAME'),
        namespace=os.getenv('PINECONE_NAMESPACE'),
        pinecone_api_key=os.getenv('PINECONE_API_KEY')
    )
    results = vector_db.similarity_search(
    # I changed the parameter from 'query' to 'dish_flavor',
    # but I forgot revise argument(인자) down this code.
        query,
        k=5,
        namespace=os.getenv('PINECONE_NAMESPACE')
    )

# Changed the code
def search_wines(dish_flavor):
    # 임베딩 모델 만들기
    embeddings = OpenAIEmbeddings(model='text-embedding-3-small')

    # vector db를 쓸 거예요.
    vector_db = PineconeVectorStore(  # Pinecone (vector) DB에 연결
        embedding=embeddings,
        index_name=os.getenv('PINECONE_INDEX_NAME'),
        namespace=os.getenv('PINECONE_NAMESPACE'),
        pinecone_api_key=os.getenv('PINECONE_API_KEY')
    )
    results = vector_db.similarity_search(
        dish_flavor,
        k=5,
        namespace=os.getenv('PINECONE_NAMESPACE')
    )
    
 # But still same error occurred..
 There's an error while loading the image: name 'query' is not defined

 # Than I thought the full running flow from the start.
 # 1. There is a parameter 'query' at the function describe_dish_flavor().
 # 2. This parameter 'query' pass on to the next function search_wines()
 # -> 'Maybe the difference of the name is the reason of the error'
 # 3. Revise the all of dish_flavor parameter into query again.
 def search_wines(query):
    # 임베딩 모델 만들기
    embeddings = OpenAIEmbeddings(model='text-embedding-3-small')

    # vector db를 쓸 거예요.
    vector_db = PineconeVectorStore(  # Pinecone (vector) DB에 연결
        embedding=embeddings,
        index_name=os.getenv('PINECONE_INDEX_NAME'),
        namespace=os.getenv('PINECONE_NAMESPACE'),
        pinecone_api_key=os.getenv('PINECONE_API_KEY')
    )
    results = vector_db.similarity_search(
        query,
        k=5,
        namespace=os.getenv('PINECONE_NAMESPACE')
    )
    return {
        "dish_flavor": query,
        "wine_reviews": "\n".join([doc.page_content for doc in results])
    }
# It works!

# Input URL: 
https://recipe1.ezmember.co.kr/cache/recipe/2016/04/18/618714c513dc25a83212b7b911cd7dfc1.jpg

# Output
```
AI wine recommendation:
샥슈카(Shakshuka)는 토마토 소스의 산미, 달걀의 고소함, 그리고 바질의 상쾌함이 어우러진 중동/북아프리카 대표 요리죠. 상큼하면서도 부드러운 풍미에 잘 어울릴 와인 페어링을 추천드리겠습니다.

주어진 와인 리뷰 중, 샥슈카와 가장 좋은 조화를 낼 수 있는 와인은 다음과 같습니다:
------
추천 와인:
Yatir 2009 Syrah (Judean Hills)

* 풍미 노트: 체리, 블랙 올리브, 오레가노, 블루베리 파이, 훈제 고기, 오렌지 껍질, 타임
* 테이스팅 코멘트: 과실 향과 허브, 스파이시함이 조화롭게 어우러지며, 산미와 타닌의 균형이 입안을 개운하게 마무리합니다.

추천 이유:
샥슈카의 토마토 산미와 달걀의 부드러움을 Syrah의 신선한 과실향(체리, 블루베리)과 허브, 오렌지 껍질 등 풍성한 풍미가 멋지게 보완합니다. 
특히 허브(오레가노, 타임)와 스파이시함이 샥슈카에 들어가는 바질, 토마토 등의 향신료와 자연스럽게 어우러져 풍미의 균형이 뛰어납니다.
적절한 산도와 부드러운 타닌은 토마토 소스의 상큼함, 달걀의 고소함을 해치지 않으면서 음식의 맛을 한층 끌어올립니다.
------
대체 추천 와인
Carmel 2010 Kayoumi Single Vineyard Shiraz (Galilee)

검은 체리, 커피, 민트, 카라멜라이즈드 과일 등 좌중을 끄는 과실미와 산뜻한 민트 풍미가 샥슈카와 상큼하고 깊이 있게 조화를 이뤄줍니다.
Château Musar 2009 Musar Jeune White (Bekaa Valley)

만약 레드 와인보다는 화이트를 원하신다면, 드라이하면서도 스모키하고 오렌지필, 흰 꽃, 건초 풍미가 토마토 본연의 맛과 달걀의 부드러움 사이에서 색다른 조합을 만들어줍니다.
------
페어링 팁
샥슈카와의 궁합을 위해서는 산미가 너무 강하지 않고, 지나치게 무겁지 않은 레드 혹은 향신료와 허브 풍미가 있는 화이트와인이 좋습니다.
와인은 약간 차게(14~16℃) 서빙하면 음식의 신선함과 더욱 잘 어울립니다.
------
결론:
“Yatir Syrah” 혹은 “Carmel Shiraz”와 샥슈카의 페어링을 추천합니다. 와인의 산도, 풍부한 과일과 허브의 향이 요리의 산미와 허브, 그리고 달걀의 고소한 맛과 더불어 멋진 하모니를 만들어낼 것입니다. 맛있는 식사와 즐거운 와인 경험이 되시길 바랍니다!
```


# VS code에서 터미널 열기 단축키 : CTRL+백틱 키



# New chapter 18_fastAPI
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
# spring의 annotaion과 같은 역할을 하는 decoration(python에선 데코라고 부름)
# fastAPI는 비동기 지원을 기본적으로 해주고 있음
async def root():
    return {"message": "Hello World"}

@app.get("/hello/{name}")
async def say_hello(name: str):
    # java에서 @PathVairable String name으로 사용하던 걸 (name: str)로 사용
    return {"message": f"Hello {name}"}

        # install uvicorn, uvicorn acts like a tomcat server
        D:\lecture\18_fastAPI>cd _01_fastapi
        D:\lecture\18_fastAPI\_01_fastapi>pip install fastAPI
        ......
        D:\lecture\18_fastAPI\_01_fastapi>pip install uvicorn
        Defaulting to user installation because normal site-packages is not writeable
        Collecting uvicorn
          Using cached uvicorn-0.35.0-py3-none-any.whl.metadata (6.5 kB)
        Requirement already satisfied: click>=7.0 in c:\users\user\appdata\roaming\python\python313\site-packages (from uvicorn) (8.2.1)
        Requirement already satisfied: h11>=0.8 in c:\users\user\appdata\roaming\python\python313\site-packages (from uvicorn) (0.16.0)
        Requirement already satisfied: colorama in c:\users\user\appdata\roaming\python\python313\site-packages (from click>=7.0->uvicorn) (0.4.6)
        Using cached uvicorn-0.35.0-py3-none-any.whl (66 kB)
        Installing collected packages: uvicorn
          WARNING: The script uvicorn.exe is installed in 'C:\Users\User\AppData\Roaming\Python\Python313\Scripts' which is not on PATH.
          Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.
        Successfully installed uvicorn-0.35.0
        
        D:\lecture\18_fastAPI\_01_fastapi>uvicorn main:app --reload
        'uvicorn' is not recognized as an internal or external command,
        operable program or batch file.
        
        D:\lecture\18_fastAPI\_01_fastapi> python -m uvicorn main:app --reload
        INFO:     Will watch for changes in these directories: ['D:\\lecture\\18_fastAPI\\_01_fastapi']
        INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
        INFO:     Started reloader process [11924] using StatReload
        INFO:     Started server process [30444]
        INFO:     Waiting for application startup.
        INFO:     Application startup complete.


# path_params.py
from fastapi import APIRouter

router = APIRouter(prefix='/path_params', tags=['path_params'])

# 경로매개변수
@router.get("/items/{item_id}") # 동적 경로
async def read_item(item_id: int):
    return {"item_id": item_id}

"""
경로 작동은 순차적으로 실행되기 때문에 /users/{user_id} 이전에 /users/me를 먼저 선언해야 한다.
"""

@router.get("/users/me")
# 위와 같이 '고정된 경로'("/users/me")를 항상 @@
async def read_user_me():
    return {"user_id": "the current user"}


@router.get("/users/{user_id}")
# 이 위와 같은 '동적 경로'("/users/{user_id}")보다 위에 작성해야한다. @@
async def read_user(user_id: str):
    return {"user_id": user_id}


from enum import Enum, StrEnum

"""
Enum을 이용해서 매개변수를 지정한 값목록안에서만 처리할 수 있다.

- Enum클래스가 str, Enum 또는 StrEnum을 상속하면, Enum객체를 str처럼 사용가능하다.
    - enum객체 is ModelName.alexnet
    - enum객체.value == "lenet"
    위와 같이 쓰지 않고, 직접 비교 가능하다.
    - enum객체 == 'alexnet'
"""
# 원래는 model_name == ModelName.alexnet 이런 식으로 사용해야하는데
# 위처럼 enum 객체 'alexnet'으로 등록하면 반복적으로 같은 내용의 코드를 작성할 필요 없이
# alexnet처럼 간단한 형태로 사용이 가능하다.
class ModelName(StrEnum):
    alexnet = "alexnet"
    resnet = "resnet"
    lenet = "lenet"


@router.get("/models/{model_name}") # 동적 경로
async def get_model(model_name: ModelName):
    # if model_name is ModelName.alexnet:
    if model_name == 'alexnet':
        return {"model_name": model_name, "message": "Deep Learning FTW!"}

    if model_name == "lenet":
        return {"model_name": model_name, "message": "LeCNN all the images"}

    return {"model_name": model_name, "message": "Have some residuals"}


# query_params.py
from fastapi import APIRouter

router = APIRouter(prefix='/query_params', tags=['query_params'])

# 쿼리매개변수 (wep 개발 기본)
# 방금 path_params.py에서 decoration(=java의 annotation)을 사용한 경로매개변수를 봤다. 
# - 경로매개변수가 아닌 매개변수는 쿼리매개변수로 사용가능하다.
# - 자료형, 기본값 지정이 가능하다.
# - 기본값을 None으로 지정하지 않으면 필수값이다.

# 가상 데이터 베이스. java에서 List<Map<String, String>>의 형태와 
# While the Python data structure is a list of dictionaries, 
# it serves the same purpose as a List<Map<String, String>> in Java. 
# Both are used to store an ordered collection of records, where each record is a set of key-value pairs.
fake_items_db = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]

@router.get("/items/")
# 함수매개변수 중 skip이나 limit이 지정되어 있지 않은 변수를 fastAPI는 자동으로
# 쿼리매개변수(query_parameter)라고 인식한다.
async def read_item(skip: int = 0, limit: int = 10):
    return fake_items_db[skip : skip + limit]


@router.get("/products/{product_id}")
async def read_product(product_id: str, q: str | int = None):
    if q:
        return {"product_id": product_id, "q": q}
    return {"product_id": product_id}


# Terminate _01_fastapi folder and run _02_params directory.
D:\lecture\18_fastAPI\_01_fastapi>cd..

D:\lecture\18_fastAPI>cd _02_params
D:\lecture\18_fastAPI\_02_params>python -m uvicorn main:app --reload


# FastAPI의 장점중의 하나= 자동으로 Swagger를 생성해준다
# Reference: https://chaechae.life/blog/fastapi-swagger-change
